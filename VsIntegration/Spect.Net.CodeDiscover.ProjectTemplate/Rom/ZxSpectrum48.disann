{
  "Labels": {
    "0": "START",
    "8": "ERROR_1",
    "16": "PRINT_A_1",
    "32": "NEXT_CHAR",
    "40": "FP_CALC",
    "48": "BC_SPACES",
    "56": "MASK_INT",
    "125": "SKIP_OVER",
    "4555": "START_NEW",
    "83": "ERROR_2",
    "5618": "PRINT_A_2",
    "28": "TEST_CHAR",
    "116": "CH_ADD_P1",
    "13147": "CALCULATE",
    "5790": "RESERVE",
    "72": "KEY_INT",
    "3082": "PO_MSG",
    "3092": "PO_TABLE",
    "3088": "PO_TOKENS",
    "3137": "PO_SEARCH",
    "3106": "PO_EACH",
    "3131": "PO_SAVE",
    "3125": "PO_TR_SP",
    "13759": "STK_PNTRS",
    "13150": "GEN_ENT_1",
    "13154": "GEN_ENT_2",
    "13157": "RE_ENTRY",
    "13164": "SCAN_ENT",
    "13184": "FIRST_3D",
    "13198": "ENT_TABLE",
    "13196": "DOUBLE_A",
    "13015": "FP_OP_ADDR",
    "12997": "stk_zero_const",
    "13000": "stk_one_const",
    "13004": "stk_half_const",
    "13006": "stk_pi_half_cons",
    "13011": "stk_ten_const",
    "13218": "fp_calc_2",
    "13225": "TEST_5_SP",
    "7941": "TEST_ROOM",
    "13236": "STACK_NUM",
    "13248": "MOVE_FP",
    "13254": "STK_DATA",
    "13256": "STK_CONST",
    "13278": "FORM_EXP",
    "13297": "STK_ZEROS",
    "13303": "SKIP_CONS",
    "13304": "SKIP_NEXT",
    "13318": "LOC_MEM",
    "13327": "get_mem_0",
    "13339": "stk_zero",
    "13357": "st_mem_0",
    "13372": "EXCHANGE",
    "13374": "SWAP_BYTE",
    "13418": "abs",
    "13428": "NEG_TEST",
    "13545": "TEST_ZERO",
    "13422": "NEGATE",
    "13443": "INT_CASE",
    "11647": "INT_FETCH",
    "11662": "INT_STORE",
    "13458": "sgn",
    "13477": "in_func",
    "7833": "FIND_INT_2",
    "13488": "IN_PK_STK",
    "13484": "peek",
    "11560": "STACK_A",
    "13491": "usr_no",
    "11563": "STACK_BC",
    "13500": "usr_string",
    "11249": "STK_FETCH",
    "13543": "REPORT_A",
    "11405": "ALPHA",
    "13523": "USR_RANGE",
    "13540": "USR_STACK",
    "13561": "GREATER_0",
    "13575": "SIGN_TO_C",
    "13569": "not_func",
    "13579": "FP_0_OR_1",
    "13574": "less_0",
    "13595": "or_oper",
    "13604": "no_and_no",
    "13613": "str_and_no",
    "14263": "C_ENT",
    "1218": "SA_BYTES",
    "1232": "SA_FLAG",
    "517": "KEY_TABLE_L",
    "85": "ERROR_3",
    "119": "TEMP_PTR_1",
    "120": "TEMP_PTR_2",
    "14446": "KEYBOARD",
    "102": "RESET",
    "112": "NO_RESET",
    "144": "SKIPS",
    "654": "KEY_SCAN",
    "662": "KEY_LINE",
    "24": "GET_CHAR",
    "683": "KEY_DONE",
    "671": "KEY_3KEYS",
    "673": "KEY_BITS",
    "703": "KEYBOARD",
    "710": "K_ST_LOOP",
    "721": "K_CH_SET",
    "798": "K_TEST",
    "753": "K_NEW",
    "819": "K_DECODE",
    "776": "K_END",
    "784": "K_REPEAT",
    "812": "K_MAIN",
    "871": "K_DIGIT",
    "847": "K_KLC_LET",
    "833": "K_E_LET",
    "842": "K_LOOK_UP",
    "868": "K_TOKENS",
    "925": "K_KLC_DGT",
    "905": "K_GRA_DGT",
    "898": "K_8_AND_9",
    "946": "K_AT_CHAR",
    "949": "BEEPER",
    "977": "BE_IX_P3",
    "978": "BE_IX_P2",
    "979": "BE_IX_P1",
    "980": "BE_IX_P0",
    "982": "BE_HandL_LP",
    "1010": "BE_AGAIN",
    "1014": "BE_END",
    "1016": "BEEP",
    "1132": "REPORT_B",
    "1061": "BE_I_OK",
    "1063": "BE_OCTAVE",
    "1134": "SEMI_TONE",
    "7828": "FIND_INT1",
    "1343": "SA_LD_RET",
    "1240": "SA_LEADER",
    "1258": "SA_SYNC_1",
    "1266": "SA_SYNC_2",
    "1287": "SA_START",
    "1278": "SA_LOOP",
    "1294": "SA_PARITY",
    "1285": "SA_LOOP_P",
    "1297": "SA_BIT_2",
    "1317": "SA_8_BITS",
    "1308": "SA_OUT",
    "1306": "SA_SET",
    "1300": "SA_BIT_1",
    "1340": "SA_DELAY",
    "1364": "SA_LD_END",
    "1366": "LD_BYTES",
    "2548": "PRINT_OUT",
    "1387": "LD_BREAK",
    "1388": "LD_START",
    "1511": "LD_EDGE_1",
    "1396": "LD_WAIT",
    "1507": "LD_EDGE_2",
    "1408": "LD_LEADER",
    "1423": "LD_SYNC",
    "1480": "LD_MARKER",
    "1449": "LD_LOOP",
    "1459": "LD_FLAG",
    "1469": "LD_VERIFY",
    "1474": "LD_NEXT",
    "1476": "LD_DEC",
    "1482": "LD_8_BITS",
    "1513": "LD_DELAY",
    "1517": "LD_SAMPLE",
    "1541": "SAVE_ETC",
    "7308": "EXPT_EXT",
    "9520": "SYNTAX_Z",
    "1618": "SA_DATA",
    "1569": "SA_SPACE",
    "1570": "SA_SPACE_1",
    "1577": "SA_BLANK",
    "1611": "SA_NAME",
    "1604": "SA_NULL",
    "1602": "REPORT_F",
    "1696": "SA_SCRD",
    "7306": "REPORT_C",
    "10418": "LOOK_VARS",
    "1650": "SA_V_OLD",
    "1648": "REPORT_2",
    "1669": "SA_V_NEW",
    "1682": "SA_DATA_1",
    "1679": "SA_V_TYPE",
    "7150": "CHECK_END",
    "1882": "SA_ALL",
    "1731": "SA_CODE",
    "1814": "SA_LINE",
    "8264": "PR_ST_END",
    "1761": "SA_CODE_1",
    "7398": "USE_ZERO",
    "1776": "SA_CODE_2",
    "7298": "EXPT_1NUM",
    "1781": "SA_CODE_3",
    "1785": "SA_CODE_4",
    "1808": "SA_TYPE_3",
    "1827": "SA_LINE_1",
    "1850": "SA_TYPE_0",
    "2416": "SA_CONTRL",
    "1895": "LD_LOOK_H",
    "1930": "LD_TYPE",
    "1958": "LD_NAME",
    "1965": "LD_CH_PR",
    "1995": "VR_CONTRL",
    "2056": "LD_CONTRL",
    "2230": "ME_CONTRL",
    "2025": "VR_CONT_1",
    "2054": "REPORT_R",
    "2036": "VR_CONT_2",
    "2048": "VR_CONT_3",
    "2050": "LD_BLOCK",
    "2073": "LD_CONT_1",
    "2085": "LD_CONT_2",
    "2094": "LD_DATA",
    "2163": "LD_PROG",
    "2124": "LD_DATA_1",
    "6632": "RECLAIM_2",
    "5717": "MAKE_ROOM",
    "6629": "RECLAIM_1",
    "2221": "LD_PROG_1",
    "2258": "ME_NEW_LP",
    "2263": "ME_OLD_LP",
    "2288": "ME_VAR_LP",
    "2271": "ME_OLD_L1",
    "2283": "ME_NEW_L2",
    "6584": "NEXT_ONE",
    "2297": "ME_OLD_VP",
    "2339": "ME_VAR_L2",
    "2313": "ME_OLD_V2",
    "2305": "ME_OLD_V1",
    "2337": "ME_VAR_L1",
    "2322": "ME_OLD_V3",
    "2334": "ME_OLD_V4",
    "2348": "ME_ENTER",
    "2366": "ME_ENT_1",
    "2389": "ME_ENT_2",
    "2392": "ME_ENT_3",
    "5633": "CHAN_OPEN",
    "5588": "WAIT_KEY",
    "2449": "SA_1_SEC",
    "2819": "PO_FETCH",
    "2777": "PO_ABLE",
    "2665": "PO_QUEST",
    "2595": "PO_BACK_1",
    "2618": "PO_BACK_3",
    "2616": "PO_BACK_2",
    "3545": "CL_SET",
    "2917": "PO_CHAR",
    "2639": "PO_ENTER",
    "2655": "PO_COMMA",
    "2755": "PO_FILL",
    "2685": "PO_TV_1",
    "2688": "PO_CHANGE",
    "8721": "CO_TEMPS",
    "2754": "PO_TAB",
    "2732": "PO_AT_ERR",
    "2751": "PO_AT_SET",
    "7839": "REPORT_B",
    "3157": "PO_SCR",
    "3206": "REPORT_5",
    "2768": "PO_SPACE",
    "3488": "PO_SPACE",
    "2780": "PO_STORE",
    "2852": "PO_ANY",
    "2812": "PO_ST_PR",
    "2800": "PO_ST_E",
    "2845": "PO_F_PR",
    "2898": "PO_Tand_UDG",
    "2872": "PO_GR_1",
    "2878": "PO_GR_2",
    "2892": "PO_GR_3",
    "2922": "PO_CHAR_2",
    "2911": "PO_T",
    "2934": "PO_CHAR_3",
    "2943": "PR_ALL",
    "2963": "PR_ALL_1",
    "3789": "COPY_BUFF",
    "2980": "PR_ALL_2",
    "2998": "PR_ALL_3",
    "2999": "PR_ALL_4",
    "3027": "PR_ALL_6",
    "3009": "PR_ALL_5",
    "3035": "PO_ATTR",
    "3066": "PO_ATTR_1",
    "2621": "PO_RIGHT",
    "2669": "PO_TV_2",
    "2677": "PO_2_OPER",
    "2682": "PO_1_OPER",
    "2695": "PO_CONT"
  },
  "Comments": {
    "654": "The initial key value for each line will be +2F, +2E,...,+28. (Eight lines.)",
    "11": "The address reached by the interpreter is copied to the error pointer before proceeding.",
    "28": "Find out if the character is printable. Return if it is so.",
    "58": "The lower two bytes of the frame counter are incremented every 20 ms.",
    "67": "The highest byte of the frame counter is only incremented when the value of the lower two bytes is zero.",
    "3083": "The high byte of the last entry on the machine stack is made zero so as to suppress trailing spaces (see below).",
    "3088": "The base address of the token",
    "3091": "Save the code on the stack. (Range +00 - +5A; RND - COPY).",
    "3092": "Locate the required entry.",
    "3095": "Print the message/token.",
    "3097": "A 'space' will be printed before the message/token if required.",
    "3106": "Collect a code.",
    "3107": "Cancel any 'inverted bit'.",
    "3109": "Print the character.",
    "3112": "Collect the code again.",
    "3113": "Advance the pointer.",
    "3114": "The 'inverted bit' goes to the carry flag and signals the end of the message/token;",
    "3115": "otherwise jump back.",
    "3117": "For messages - D holds +00; for tokens - D holds +00 - +5A.",
    "3120": "Jump forward if the last character was a '$'.",
    "3124": "Return if the last character was any other before 'A'.",
    "3125": "Examine the value in D and return if it indicates a message, RND, INKEY$ or PI.",
    "3129": "All other cases will require a 'trailing space'.",
    "13147": "Presume a unary operation and therefore set HL to point to the start of the 'last value' on the calculator stack and DE one-past this floating-point number (STKEND).",
    "13151": "Either, transfer a single operation offset to BREG temporarily, or, when using the subroutine recursively pass the parameter to BREG to be used as a counter.",
    "13154": "The return address of the sub-routine is store in H'L'. This saves the pointer to the first literal. Entering the CALCULATOR at GEN-ENT-2 is used whenever BREG is in use as a",
    "13157": "A loop is now entered to handle each literal in the list that follows the calling instruction;",
    "13161": "so first, always set to STKEND. Go to the alternate register set, and fetch the literal for this loop.",
    "13163": "Make H'L' point to the next literal.",
    "13164": "This pointer is saved briefly on the machine stack. SCAN-ENT is used by the SINGLE CALCULATION subroutine to find the subroutine that is required.",
    "13165": "Test the A register.",
    "13166": "Separate the simple literals from the multi-purpose literals. Jump with literals 00 - 3D.",
    "13169": "Save the literal in D.",
    "13170": "Continue only with bits 5 & 6.",
    "13172": "Four right shifts make them now bits 1 & 2.",
    "13176": "The offsets required are 3E-41.",
    "13178": "And L will now hold double the required offset.",
    "13180": "Now produce the parameter by taking bits 0,1,2,3 & 4 of the literal; keep the parameter in A.",
    "13184": "Jump forward if performing a unary operation.",
    "13188": "All of the subroutines that perform binary operations require that HL points to the first operand",
    "13189": "and DE points to the second operand (the 'last value') as they appear on the calculator stack.",
    "13196": "As each entry in the table of addresses takes up two bytes the offset produced is doubled.",
    "13015": "\"jump-true\", \"exchange\", \"delete\", \"subtract\"",
    "13023": "\"multiply\", \"division\", \"to-power\", \"or\"",
    "13031": "\"no-&-no\", \"no-l-eql\", \"no-gr-eq\", \"nos-neql\"",
    "13039": "\"no-grtr\", \"no-less\", \"nos-eql\", \"addition\"",
    "13047": "\"str-&-no\", \"str-l-eql\", \"str-gr-eq\", \"strs-neql\"",
    "13055": "\"str-grtr\", \"str-less\", \"strs-eql\", \"strs-add\"",
    "13063": "\"val$\", \"usr-$\", \"read-in\", \"negate\"",
    "13071": "\"code\", \"val\", \"len\", \"sin\"",
    "13079": "\"cos\", \"tan\", \"asn\", \"acs\" ",
    "13087": "\"atn\", \"ln\", \"exp\", \"int\"",
    "13095": "\"sqr\", \"sgn\", \"abs\", \"peek\"",
    "13103": "\"in\", \"usr-no\", \"str$\", \"chr$\"",
    "13111": "\"not\", \"duplicate\", \"n-mod-m\", \"jump\"",
    "13119": "\"stk-data\", \"dec-jr-nz\", \"less-0\", \"greater-0\"",
    "13127": "\"end-calc\", \"get-argt\", \"truncate\", \"fp-calc-2\"",
    "13135": "\"e-to-fp\", \"re-stack\", \"series-06\", \"stk-zero\"",
    "13143": "\"st-mem-0\", \"get-mem-0\"",
    "13198": "The base address of the table.",
    "13201": "The address of the required table entry is formed in HL;",
    "13203": "and the required subroutine address is loaded into the DE register pair.",
    "13211": "The RE-ENTRY is put on the machine stack underneath the subroutine address.",
    "13212": "Return to the main set of registers.",
    "13213": "The current value of BREG is transferred to the B register thereby returning the single operation offset.",
    "13217": "An indirect jump to the required subroutine.",
    "13218": "Discard the RE-ENTRY address.",
    "13219": "Transfer the offset to A.",
    "13222": "Enter the alternate register set.",
    "13223": "Jump back to find the required address; stack the RE-ENTRY address and jump to the subroutine for the operation.",
    "13225": "Save DE briefly.",
    "13226": "Save HL briefly.",
    "13227": "Specify the test is for 5 bytes.",
    "13230": "Make the test.",
    "13233": "Restore HL.",
    "13234": "Restore DE.",
    "13235": "Finished.",
    "13236": "Copy STKEND to DE as destination address.",
    "13240": "Move the number.",
    "13243": "Reset STKEND from DE.",
    "13247": "Finished.",
    "13248": "A test is made for room.",
    "13251": "Move the five bytes involved.",
    "13253": "Finished.",
    "13254": "This subroutine performs the manipulatory operation of adding a 'last value' to the calculator stack; hence HL is set to point one-past the present 'last value' and hence point to the result.",
    "13256": "Now test that there is indeed",
    "13259": "Go to the alternate register set and stack the pointer to the next literal.",
    "13262": "Switch over the result pointer and the next literal pointer.",
    "13263": "Save BC briefly.",
    "13264": "The first literal is put into A and divided by Hex.40 to give the integer values 0, 1, 2 or 3.",
    "13270": "The integer value is transferred to C and incremented, thereby giving the range 1, 2, 3 or 4 for the number of literals that will be needed.",
    "13271": "The literal is fetch anew, reduced mod Hex.40 and discarded as inappropriate if the remainder if zero;",
    "13276": "in which case the next literal is fetched and used unreduced.",
    "13278": "The exponent, e, is formed by the addition of Hex.50 and passed to the calculator stack as the first of the five bytes of the result.",
    "13281": "The number of literals specified in C are taken from the source and entered into the bytes of the result.",
    "13290": "Restore BC.",
    "13291": "Return the result pointer to HL and the next literal pointer to its usual position in H' & L'.",
    "13295": "The number of zero bytes required at this stage is given by 5-C-1; and this number of zeros is added to the result to make up the required five bytes.",
    "13303": "The subroutine returns if the parameter is zero, or when the requested constant has been reached.",
    "13305": "Save the parameter.",
    "13306": "Save the result pointer.",
    "13307": "The dummy address.",
    "13310": "Perform imaginary stacking of an expanded constant.",
    "13313": "Restore the result pointer.",
    "13314": "Restore the parameter.",
    "13315": "Count the loops.",
    "13316": "Jump back to consider the value of the counter.",
    "13318": "Copy the parameter to C.",
    "13319": "Double the parameter.",
    "13320": "Double the result.",
    "13321": "Add the value of the parameter to give five times the original value.",
    "13322": "This result is wanted in the BC register pair.",
    "13325": "Produce the new base address.",
    "13326": "Finished.",
    "13327": "Save the result pointer.",
    "13328": "Fetch the pointer to the current memory area (see above).",
    "13331": "The base address is found.",
    "13334": "The five bytes are moved.",
    "13337": "Set the result pointer.",
    "13338": "Finished.",
    "13339": "Set HL to hold the result pointer.",
    "13346": "Go to the alternate register set and save the next literal pointer.",
    "13343": "The base address of the calculator's table of constants.",
    "13347": "Find the requested base address.",
    "13350": "Expand the constant.",
    "13354": "Restore the next literal pointer.",
    "13356": "Finished.",
    "13357": "Save the result pointer.",
    "13358": "Source to DE briefly.",
    "13359": "Fetch the pointer to the current memory area.",
    "13362": "The base address is found.",
    "13369": "'Last value' +5, i.e. STKEND, to DE.",
    "13365": "Exchange source and destination pointers.",
    "13366": "The five bytes are moved.",
    "13370": "Result pointer to HL.",
    "13371": "Finished.",
    "13372": "There are five bytes involved.",
    "13374": "Each byte of the second number.",
    "13375": "Each byte of the first number.",
    "13376": "Switch source and destination.",
    "13377": "Now to the first number.",
    "13378": "Now to the second number.",
    "13379": "Move to consider the next pair of bytes.",
    "13381": "Exchange the five bytes.",
    "13383": "Get the pointers correct as the number 5 is an odd number.",
    "13384": "Finished.",
    "13418": "B is set to FF hex.",
    "13420": "The jump is made into 'unary minus'.",
    "13422": "If the number is zero, the subroutine returns leaving 00 00 00 00 00 unchanged.",
    "13426": "B is set to +00 hex for 'negate'.",
    "13428": "If the first byte is zero, the jump is made to deal with a 'small integer'.",
    "13432": "Point to the second byte.",
    "13433": "Get +FF for 'abs', +00 for 'negate'.",
    "13434": "Now +80 for 'abs', +00 for 'negate'.",
    "13436": "This sets bit 7 for 'abs', but changes nothing for 'negate'.",
    "13437": "Now bit 7 is changed, leading to bit 7 of byte 2 reset for 'abs', and simply changed for 'negate'.",
    "13440": "The new second byte is stored.",
    "13441": "HL points to the first byte again.",
    "13442": "Finished.",
    "13443": "Save STKEND in DE.",
    "13444": "Save pointer to the number in HL.",
    "13445": "Fetch the sign in C, the number in DE.",
    "13448": "Restore the pointer to the number in HL.",
    "13449": "Get +FF for 'abs', +00 for 'negate'",
    "13450": "Now +FF for 'abs', no change for 'negate'.",
    "13451": "Now +00 for 'abs', and a changed byte for 'negate': store it in C.",
    "13453": "Store result on the stack.",
    "13456": "Return STKEND to DE.",
    "13457": "Finished.",
    "13461": "If X is zero, just return with zero as the 'last value'.",
    "13462": "Save the pointer to STKEND.",
    "13463": "Store 1 in DE.",
    "13466": "Point to the second byte of X.",
    "13467": "Rotate bit 7 into the carry flag.",
    "13469": "Point to the destination again.",
    "13470": "Set C to zero for positive X and to FF hex for negative X.",
    "13472": "Stack 1 or -1 as required.",
    "13475": "Restore the pointer to STKEND.",
    "13476": "Finished.",
    "13477": "The 'last value', X, is compressed into BC.",
    "13480": "The signal is received.",
    "13484": "Evaluate the 'last value', rounded to the nearest integer; test that it is in range and return it in BC.",
    "13487": "Fetch the required byte.",
    "13488": "Exit by jumping to STACK-A.",
    "13491": "Evaluate the 'last value', rounded to the nearest integer; test that it is in range and return it in BC.",
    "13494": "Make the return address be that of the subroutine STACK-BC.",
    "13498": "Make an indirect jump to the required location.",
    "13500": "Fetch the parameters of the X$",
    "13503": "Decrease the length by 1 to test it.",
    "13506": "If the length was not 1, then jump to give error report A.",
    "13508": "Fetch the single code of the string.",
    "13509": "Does it denote a letter?",
    "13512": "If so, jump to gets its address.",
    "13514": "Reduce range for actual user-defined graphics to 0 - 20 decimal.",
    "13516": "Give report A if out of range.",
    "13518": "Test the range again.",
    "13520": "Give report A if out of range.",
    "13522": "Make range of user-defined graphics 1 to 21 decimal, as for a to u.",
    "13523": "Now make the range 0 to 20 decimal in each case.",
    "13524": "Multiply by 8 to get an offset for the address.",
    "13527": "Test the range of the offset.",
    "13529": "Give report A if out of range.",
    "13531": "Fetch the address of the first user-defined graphic in BC.",
    "13535": "Add C to the offset.",
    "13536": "Store the result back in C.",
    "13537": "Jump if there is no carry.",
    "13539": "Increment B to complete the address.",
    "13540": "Jump to stack the address.",
    "13545": "Save HL on the stack.",
    "13546": "Save BC on the stack.",
    "13547": "Save the value of A in B.",
    "13548": "Get the first byte.",
    "13549": "Point to the second byte.",
    "13550": "OR first byte with second.",
    "13551": "Point to the third byte.",
    "13552": "OR the result with the third byte.",
    "13553": "Point to the fourth byte.",
    "13554": "OR the result with the fourth byte.",
    "13555": "Restore the original value of A.",
    "13556": "And of BC.",
    "13557": "Restore the pointer to the number to HL.",
    "13558": "Return with carry reset if any of the four bytes was non-zero.",
    "13559": "Set the carry flag to indicate that the number was zero, and return.",
    "13561": "Is the 'last-value' zero?",
    "13564": "If so, return.",
    "13567": "Jump forward to LESS THAN ZERO but signal the opposite action is needed.",
    "13569": "The carry flag will be set only if the 'last value' is zero; this gives the correct result.",
    "13572": "Jump forward.",
    "13574": "Clear the A register.",
    "13575": "Point to the sign byte.",
    "13576": "The carry is reset for a positive number and set for a negative number;",
    "13578": "when entered from GREATER-0 the opposite sign goes to the carry.",
    "13579": "Save the result pointer.",
    "13580": "Clear A without disturbing the carry.",
    "13582": "Set the first byte to zero.",
    "13583": "Point to the second byte.",
    "13584": "Set the second byte to zero.",
    "13585": "Point to the third byte.",
    "13586": "Rotate the carry into A, making A one if the carry was set, but zero if the carry was reset.",
    "13587": "Set the third byte to one or zero.",
    "13588": "Ensure that A is zero again.",
    "13589": "Point to the fourth byte.",
    "13590": "Set the fourth byte to zero.",
    "13591": "Point to the fifth byte.",
    "13592": "Set the fifth byte to zero.",
    "13593": "Restore the result pointer.",
    "13595": "Point HL at Y, the second number.",
    "13596": "Test whether Y is zero.",
    "13599": "Restore the pointers.",
    "13600": "Return if Y was zero; X is now the 'last value'.",
    "13601": "Set the carry flag",
    "13602": "and jump back to set the 'last value' to 1.",
    "13604": "Point HL at Y, DE at X.",
    "13605": "Test whether Y is zero.",
    "13608": "Swap the pointers back.",
    "13609": "Return with X as the 'last value' if Y was non-zero.",
    "13610": "Reset the carry flag",
    "13611": "and jump back to set the 'last value' to zero.",
    "13613": "Point HL at Y, DE at X$.",
    "13614": "Test whether Y is zero.",
    "13617": "Swap the pointers back.",
    "13618": "Return with X$ as the 'last value' if Y was non-zero.",
    "13619": "Save the pointer to the number.",
    "13620": "Point to the fifth byte of the string parameters i.e. length-high.",
    "13621": "Clear the A register.",
    "13622": "Length-high is now set to zero.",
    "13623": "Point to length-low.",
    "13624": "Length-low is now set to zero.",
    "13625": "Restore the pointer.",
    "13626": "Return with the string parameters being the 'last value'.",
    "14261": "X",
    "14262": "W",
    "14263": "W, W",
    "14264": "W, W, W",
    "14265": "W, W*W",
    "14266": "W, W*W, W*W",
    "14267": "W, 2*W*W",
    "14268": "W, 2*W*W, 1",
    "14269": "W, 2*W*W-1 = Z",
    "14295": "SIN (PI*W/2) = SIN X (or = COS X)",
    "14270": "W, Z",
    "72": "Save the current values held in these registers.",
    "74": "Now scan the keyboard.",
    "81": "The maskable interrupt is enabled before returning.",
    "83": "The address on the stack points to the error code.",
    "85": "It is transferred to ERR-NR.",
    "88": "The machine is cleared before exiting via SET-STK.",
    "102": "Save the current values held in these registers.",
    "104": "The two bytes of NMIADD must both be zero for the reset to occur.",
    "109": "Note: This should have been 'JR Z'!",
    "111": "Jump to START.",
    "112": "Restore the current values to these registers and return.",
    "116": "Fetch the address.",
    "119": "Increment the pointer.",
    "120": "Set CH-ADD.",
    "123": "Fetch he addressed value and then return.",
    "125": "Return with the carry flag reset if ordinary character code.",
    "128": "Return if the end of the line has been reached.",
    "131": "Return with codes +00 to +0F but with carry set.",
    "134": "Return with codes +18 to +20 again with carry set.",
    "138": "Skip-over once.",
    "139": "Jump forward with codes +10 to +15 (INK to OVER).",
    "143": "Skip-over once more (AT & TAB).",
    "145": "Return with the carry flag set and CH-ADD holding the appropriate address.",
    "656": "Initialise DE to 'no-key'.",
    "659": "C = port address, B = counter.",
    "662": "Read from the port specified.",
    "664": "A pressed key in the line will set its respective bit (from bit 0 - outer key, to bit 4 - inner key).",
    "671": "If three keys are being pressed on the keyboard then the D register will no longer hold +FF - so return if this happens.",
    "667": "Jump forward if none of the five keys in the line are being pressed.",
    "673": "Repeatedly subtract '8' from the preset key value until a key-bit is found.",
    "679": "Copy any earlier key value to the D register.",
    "680": "Pass the new key value to the E register.",
    "681": "If there is a second, or possibly a third, pressed key in this line then jump back.",
    "683": "The line has been scanned so the initial key value is reduced for the next pass.",
    "684": "The counter is shifted and the jump taken if there are still lines to be scanned.",
    "688": "Accept any key value for a pair of keys if the 'D' key is CAPS SHIFT.",
    "691": "Accept the key value for a pair of keys if the 'D' key is SYMBOL SHIFT.",
    "697": "It is however possible for the 'E' key of a pair to be SYMBOL SHIFT - so this has to be considered.",
    "702": "Return with the zero flag set if it was SYMBOL SHIFT and 'another key'; otherwise reset.",
    "703": "Fetch a key value in the DE register pair but return immediately if the zero pair flag is reset.",
    "707": "Start with KSTATE0.",
    "710": "Jump forward if a 'set is free'; i.e. KSTATE0/4 holds +FF.",
    "721": "Fetch the low byte of the address and jump back if the second set has still to be considered.",
    "715": "However if the set is not free decrease its '5 call counter' and when it reaches zero signal then set as free.",
    "728": "Make the necessary tests and return if needed. Also change the key value to a 'main code'.",
    "732": "Look first at KSTATE0.",
    "735": "Jump forward if the codes match - indicating a repeat.",
    "738": "Save the address of KSTATE0.",
    "739": "Now look at KSTATE4.",
    "742": "Jump forward if the codes match - indicating a repeat.",
    "749": "Now consider the first set.",
    "750": "Continue if the set is 'free' but exit from the KEYBOARD subroutine if not.",
    "753": "The code is passed to the E register and to KSTATE0/4.",
    "756": "The '5 call counter' for this set is reset to '5'.",
    "758": "The third system variable of the set holds the REPDEL value (normally 0.7 secs.).",
    "762": "Point to KSTATE3/7.",
    "764": "Fetch MODE.",
    "767": "Fetch FLAGS.",
    "770": "Save the pointer whilst the 'main code' is decoded.",
    "775": "The final code value is saved in KSTATE3/7; from where it is collected in case of a repeat.",
    "776": "Enter the final code value into LAST-K and signal 'a new key'.",
    "783": "Finally return.",
    "784": "Point to the '5 call counter' of the set being used and reset it to '5'.",
    "787": "Point to the third system variable - the REPDEL/REPPER value, and decrement it.",
    "789": "Exit from the KEYBOARD subroutine if the delay period has not passed.",
    "790": "However once it has passed the delay period for the next repeat is to be REPPER.",
    "794": "The repeat has been accepted so the final code value is fetched from KSTATE3/7 and passed to K-END.",
    "798": "Copy the shift byte.",
    "799": "Clear the D register for later.",
    "801": "Move the key number.",
    "802": "Return now if the key was 'CAPS SHIFT' only or 'no-key'.",
    "805": "Jump forward unless the 'E' was SYMBOL SHIFT.",
    "809": "However accept SYMBOL SHIFT and another key; return with SYMBOL SHIFT only.",
    "812": "The base address of the table.",
    "815": "Index into the table and fetch the 'main code'.",
    "817": "Signal 'valid keystroke' before returning.",
    "819": "Copy the 'main code'.",
    "820": "Jump forward if a digit key is being considered; also SPACE, ENTER & both shifts.",
    "824": "Decrement the MODE value.",
    "825": "Jump forward, as needed, for modes 'K', 'L', 'C' & 'E'.",
    "830": "Add the offset.",
    "832": "Return with the 'final code'.",
    "833": "The base address for table 'b'.",
    "836": "Jump forward to use this table if neither shift key is being pressed.",
    "839": "Otherwise use the base address for table 'c'.",
    "842": "Clear the D register.",
    "844": "Index the required table and fetch the 'final code'.",
    "846": "Then return.",
    "847": "The base address for table 'e'",
    "850": "Jump back if using the SYMBOL SHIFT key and a letter key.",
    "854": "Jump forward if currently in 'K' mode.",
    "858": "If CAPS LOCK is set then return with the 'main code'",
    "863": "Also return in the same manner if CAPS SHIFT is being pressed.",
    "865": "However if lower case codes are required then +20 has to be added to the 'main code' to give the correct 'final code'.",
    "868": "Add the required offset and return.",
    "871": "Proceed only with the digit keys. i.e. Return with SPACE (+20), ENTER (+0D) & both shifts (+0E).",
    "874": "Now separate the digit keys into three groups - according to the mode.",
    "875": "Jump with 'K', 'L' & 'C' modes;",
    "878": "and also with 'G' mode.",
    "880": "The base address for table 'f'.",
    "883": "Use this table for SYMBOL SHIFT & a digit key in extended mode.",
    "887": "Jump forward with digit keys '8' and '9'.",
    "891": "Reduce the range +30 to +37 giving +10 to +17.",
    "893": "Return with this 'paper colour code' if the CAPS SHIFT is not being used.",
    "895": "But if it is then the range is to be +18 to +1F instead - indicating an 'ink colour code'.",
    "898": "+38 & +39 go to +02 & +03.",
    "900": "Return with these codes if CAPS SHIFT is not being used. (These are 'BRIGHT' codes.)",
    "902": "Subtract '2' is CAPS SHIFT is being used; giving +00 & +01 (as 'FLASH' codes).",
    "905": "The base address of table 'd'.",
    "908": "Use this table directly for both digit key '9' that is to give GRAPHICS,",
    "912": "and digit key '0' that is to give DELETE.",
    "916": "For keys '1' to '8' make the range +80 to +87.",
    "920": "Return with a value from this range if neither shift key is being pressed.",
    "922": "But if 'shifted' make the range +88 to +8F.",
    "925": "Return directly if neither shift key is being used. (Final codes +30 to +39.)",
    "927": "Use table 'd' if the CAPS SHIFT key is also being pressed.",
    "934": "Reduce the range to give +20 to +29.",
    "936": "Separate the '@' character from the others.",
    "940": "The '-' character has also to be separated.",
    "942": "Return now with the 'final codes' +21, +23 to +29.",
    "943": "Give the '-' character a code of +5F.",
    "946": "Give the '@' character a code of +40.",
    "949": "Disable the interrupt for the duration of a 'beep'.",
    "950": "Save L temporarily.",
    "951": "Each '1' in the L register is to count '4' T states, but take INT (L/4) and count '16' T states instead.",
    "955": "Go back to the original value in L and find how many were lost by taking INT (L/4).",
    "961": "The base address of the timing loop.",
    "965": "Alter the length of the timing loop. Use an earlier starting point for each '1' lost by taking INT (L/4).",
    "967": "Fetch the present border colour and move it to bits 2, 1 & 0 of the A register.",
    "975": "Ensure the MIC output is 'off'.",
    "977": "Add '4' T states for each earlier entry port that is used.",
    "980": "The values in the B & C registers will come from H & L registers - see below.",
    "982": "The 'timing loop'.",
    "983": "i.e. 'BC' * '4' T states.",
    "985": "(But note that at the half-cycle point - C will be equal to 'L+1'.)",
    "991": "Flip bit 4.",
    "993": "Perform the OUT operation; leaving the border unchanged.",
    "995": "Reset the B register.",
    "996": "Save the A register.",
    "997": "Jump if at the half-cycle point.",
    "1001": "Jump forward if the last complete pass has been made already.",
    "1005": "Fetch the saved value.",
    "1006": "Reset the C register.",
    "1007": "Decrease the pass counter.",
    "1008": "Jump back to the required starting location of the loop.",
    "1010": "Reset the C register.",
    "1011": "Add '16' T states as this path is shorter.",
    "1012": "Jump back.",
    "1014": "Enable interrupt.",
    "1015": "Finally return.",
    "1016": "The floating-point calculator is used to manipulate the two values - t & P.",
    "1017": "t, P, P",
    "1018": "t, P, i",
    "1019": "t, P, i (mem-0 holds i)",
    "1020": "t, p (where p is the fractional part of P)",
    "1021": "Stack the decimal value 'K'.",
    "1022": "which is a little below 12*(2^0.5)-1",
    "1027": "t, p*K",
    "1029": "t, p*K+1",
    "1028": "t, p*K, 1",
    "1031": "This is 'mem-0-1st (MEMBOT).",
    "1034": "Fetch the exponent of i.",
    "1035": "Give an error if i is not in the integral (short) form.",
    "1038": "Copy the sign byte to the C register.",
    "1041": "Copy the low-byte to the B register.",
    "1046": "Again give report B if i does not satisfy the test: -128<=i<=+127",
    "1052": "Fetch the low-byte and test it further.",
    "1055": "Accept -60<=i<=67.",
    "1058": "Reject -128 to -61.",
    "1061": "Start '6' octaves below middle C.",
    "1064": "Repeatedly reduce i in order to find the correct octave.",
    "1068": "Ass back the last subtraction.",
    "1070": "Save the octave number.",
    "1071": "The base address of the 'semi-tone table'.",
    "1074": "Consider the table and pass the 'A th.' value to the calculator stack. (Call it C.)",
    "1080": "t, pK+1, C",
    "1081": "t, C*(pK+1)",
    "1083": "Fetch the octave number. Multiply the 'last value' by '2 to the power of the octave number'.",
    "1086": "t, f",
    "1087": "The frequency is put aside for the moment in mem-0.",
    "1089": "t, t",
    "1091": "The value 'INT t' must be in the range +00 to +0A.",
    "1098": "t",
    "1099": "t, f",
    "1101": "f*t, t",
    "1100": "f*t",
    "1103": "f*t, f, 437.500",
    "1102": "The value '3.5 * 10^6/8' is formed on the top of the calculator stack.",
    "1108": "f*t, 437.500, f",
    "1109": "f*t, 437.500/f",
    "1113": "f*t, 437.500/f - 30.125",
    "1115": "The 'timing loop' value is compressed into the BC register pair;",
    "1118": "and saved.",
    "1119": "The 'f*t' value is compressed into the BC register pair.",
    "1122": "Move the 'timing loop' value to the HL register pair.",
    "1123": "Move the 'f*t' value to the DE register pair.",
    "1125": "Return if 'f*t' has given the result of 'no cycles' required.",
    "1154": "329.63Hz: E",
    "1149": "311.12Hz: D#",
    "1144": "293.66Hz: D",
    "1139": "277.18Hz: C#",
    "1134": "261.63Hz: C",
    "1159": "349.23Hz: F",
    "1164": "369.99Hz: F#",
    "1169": "392.00Hz: G",
    "1174": "415.30Hz: G#",
    "1179": "440.00Hz: A",
    "1184": "466.16Hz: A#",
    "1189": "493.88Hz: B",
    "1218": "Pre-load the machine stack with the address - SA/LD-RET.",
    "1222": "This constant will give a leader of about 5 secs. for a 'header'.",
    "1225": "Jump forward if SAVEing a header.",
    "1229": "This constant will give a leader of about 2 secs. for a program/data block.",
    "1232": "The flag is saved.",
    "1233": "The 'length' is incremented and the 'base address' reduced to allow for the flag.",
    "1236": "The maskable interrupt is disabled during the SAVE.",
    "1237": "Signal 'MIC on' and border to be RED.",
    "1239": "Give a value to B.",
    "1240": "The main timing period.",
    "1242": "MIC on/off, border RED/CYAN, on each pass.",
    "1246": "The main timing constant.",
    "1248": "Decrease the low counter.",
    "1249": "Jump back for another pulse.",
    "1251": "Allow for the longer path (-reduce by 13 T states).",
    "1252": "Decrease the high counter.",
    "1253": "Jump back for another pulse until completion of the leader.",
    "1258": "MIC off for 667 T states from 'OUT to OUT'.",
    "1260": "MIC on and RED.",
    "1262": "Signal 'MIC off & CYAN'.",
    "1264": "MIC on for 735 T States from 'OUT to OUT'.",
    "1268": "Now MIC off & border CYAN.",
    "1270": "+3B is a timing constant; +0E signals 'MIC off & YELLOW'.",
    "1273": "Fetch the flag and pass it to the L register for 'sending'.",
    "1275": "Jump forward into the SAVEing loop.",
    "1278": "The 'length' counter is tested and the jump taken when it has reached zero.",
    "1282": "Fetch the next byte that is to be SAVEd.",
    "1285": "Fetch the current 'parity'.",
    "1286": "Include the present byte.",
    "1287": "Restore the 'parity'. Note that on entry here the 'flag' value initialises 'parity'.",
    "1288": "Signal 'MIC on & BLUE'.",
    "1290": "Set the carry flag. This will act as a 'marker' for the 8 bits of a byte.",
    "1291": "Jump forward.",
    "1294": "Get final 'parity' value.",
    "1295": "Jump back.",
    "1297": "Come here on the second pass and fetch 'MIC off & YELLOW'.",
    "1298": "Set the zero flag to show 'second pass'.",
    "1300": "The main timing loop; always 801 T states on a 2nd. pass.",
    "1302": "Jump, taking the shorter path, if SAVEing a '0'.",
    "1304": "However if SAVEing a '1' then add 855 T states.",
    "1308": "On the 1st. pass 'MIC on & BLUE' and on the 2nd. pass 'MIC off & YELLOW'.",
    "1310": "Set the timing constant for the second pass.",
    "1312": "Jump back at the end of the first pass; otherwise reclaim 13 T states.",
    "1315": "Clear the carry flag and set A to hold +01 (MIC on & BLUE) before continuing into the '8 bit loop'.",
    "1317": "Move bit 7 to the carry and the 'marker' leftwards.",
    "1319": "SAVE the bit unless finished with the byte.",
    "1322": "Decrease the 'counter'.",
    "1323": "Advance the 'base address'.",
    "1325": "Set the timing constant for the first bit of the next byte.",
    "1327": "Return (to SA/LD-RET) if the BREAK key is being pressed.",
    "1333": "Otherwise test the 'counter and jump back even if it has reached zero (so as to send the 'parity' byte).",
    "1338": "Exit when the 'counter reaches +FFFF. But first give a short delay.",
    "1343": "Save the carry flag. (It is reset after a LOADing error.)",
    "1344": "Fetch the original border colour from its system variable.",
    "1349": "Move the border colour to bits 2, l & 0.",
    "1352": "Set the border to its original colour.",
    "1354": "Read the BREAK key for a last time.",
    "1359": "Enable the maskable interrupt.",
    "1360": "Jump unless a break is to be made.",
    "1364": "Retrieve the carry flag.",
    "1365": "Return to the calling routine.",
    "2465": "Initial byte is stepped over.",
    "2466": "\"Start tape, then press any key.\"",
    "2497": "\"'carriage return' - Program:\"",
    "2507": "\"'carriage return' - Number array:\"",
    "2522": "\"'carriage return' - Character array:\"",
    "2540": "\"'carriage return' - Bytes:\"",
    "1366": "This resets the zero flag. (D cannot hold +FF.)",
    "1367": "The A register holds +00 for a header and +FF for a block of data. The carry flag is reset for VERIFYing and set for LOADing.",
    "1368": "Restore D to its original value.",
    "1369": "The maskable interrupt is now disabled.",
    "1370": "The border is made WHITE.",
    "1374": "Preload the machine stack with the address - SA/LD-RET.",
    "1378": "Make an initial read of port '254'.",
    "1380": "Rotate the byte obtained but keep only the EAR bit,",
    "1385": "Store the value in the C register. - (+22 for 'off' and +02 for 'on' - the present EAR state.)",
    "1383": "Signal 'RED' border.",
    "1386": "Set the zero flag.",
    "1387": "Return if the BREAK key is being pressed.",
    "1388": "Return with the carry flag reset if there is no 'edge' within approx. 14,000 T states. But if an 'edge' is found the border will go CYAN.",
    "1393": "The length of this waiting period will be almost one second in duration.",
    "1403": "Continue only if two edges are found within the allowed time period.",
    "1408": "The timing constant",
    "1413": "Continue only if two edges are found within the allowed time period.",
    "1415": "However the edges must have been found within about 3,000 T states of each other.",
    "1420": "Count the pair of edges in the H register until '256' pairs have been found.",
    "1423": "The timing constant.",
    "1425": "Every edge is considered until two edges are found close together - these will be the start and finishing edges of the 'off' sync pulse.",
    "1435": "The finishing edge of the 'on' pulse must exist. (Return carry flag reset.)",
    "1439": "The border colours from now on will be BLUE & YELLOW.",
    "1443": "Initialise the 'parity matching' byte to zero.",
    "1445": "Set the timing constant for the flag byte.",
    "1447": "Jump forward into the byte LOADING loop.",
    "1449": "Fetch the flags.",
    "1450": "Jump forward only when handling the first byte.",
    "1452": "Jump forward if VERIFYing a tape.",
    "1454": "Make the actual LOAD when required.",
    "1457": "Jump forward to LOAD the next byte.",
    "1459": "Keep the carry flag in a safe place temporarily.",
    "1461": "Return now if the type flag does not match the first byte on the tape. (Carry flag reset.)",
    "1463": "Restore the carry flag now.",
    "1466": "Increase the counter to compensate for its 'decrease' after the jump.",
    "1469": "Fetch the original byte.",
    "1472": "Match it against the new byte.",
    "1473": "Return if 'no match'. (Carry flag reset.)",
    "1474": "Increase the 'destination'.",
    "1476": "Decrease the 'counter'.",
    "1477": "Save the flags.",
    "1478": "Set the timing constant.",
    "1480": "Clear the 'object' register apart from a 'marker' bit.",
    "1482": "Find the length of the 'off' and 'on' pulses of the next bit.",
    "1485": "Return if the time period is exceeded. (Carry flag reset.)",
    "1486": "Compare the length against approx. 2,400 T states; resetting the carry flag for a '0' and setting it fore '1'.",
    "1489": "Include the new bit in the L register.",
    "1493": "Jump back whilst there are still bits to be fetched.",
    "1491": "Set the timing constant for the next bit.",
    "1496": "Fetch the 'parity matching' byte and include the new byte.",
    "1498": "Save it once again.",
    "1499": "Make a further pass if the DE register pair does not hold zero.",
    "1503": "Fetch the 'parity matching' byte.",
    "1504": "Return with the carry flat set if the value is zero. (Carry flag reset if in error.)",
    "1507": "In effect call LD-EDGE-1 twice; returning in between if there is an error.",
    "1511": "Wait 358 T states before entering the sampling loop.",
    "1517": "Count each pass.",
    "1518": "Return carry reset & zero set if 'time-up'.",
    "1519": "Read from port +7FFE.",
    "1521": "i.e. BREAK & EAR.",
    "1523": "Shift the byte.",
    "1524": "Return carry reset & zero reset if BREAK was pressed.",
    "1525": "Now test the byte against the 'last edge-type'; jump back unless it has changed.",
    "1530": "Change the 'last edge-type' and border colour.",
    "1533": "Keep only the border colour.",
    "1535": "Signal 'MIC off'.",
    "1537": "Change the border colour (RED/CYAN or BLUE/YELLOW).",
    "1539": "Signal the successful search before returning.",
    "1541": "Drop the address - SCAN-LOOP.",
    "1542": "Reduce T-ADDR-lo by +E0; giving +00 for SAVE, +01 for LOAD, +02 for VERIFY and +03 for MERGE.",
    "1550": "Pass the parameters of the 'name' to the calculator stack.",
    "1553": "Jump forward if checking syntax.",
    "1558": "Allow seventeen locations for the header of a SAVE but thirty four for the other commands.",
    "1569": "The required amount of space is made in the work space.",
    "1570": "Copy the start address to the IX register pair.",
    "1573": "A program name can have up to ten characters but first enter eleven space characters into the prepared area.",
    "1581": "A null name is +FF only.",
    "1586": "The parameters of the name are fetched and its length is tested.",
    "1585": "The parameters of the name are fetched and its length is tested.",
    "1588": "This is '-10'.",
    "1592": "In effect jump forward if the length of the name is not too long. (i.e. No more than ten characters.)",
    "1596": "But allow for the LOADing, VERIFYing and MERGEing of programs with 'null' names or extra long names.",
    "1604": "Jump forward if the name has a 'null' length.",
    "1608": "But truncate longer names.",
    "1611": "Copy the start address to the HL register pair.",
    "1613": "Step to the second location.",
    "1615": "Switch the pointers over and copy the name.",
    "1618": "Is the present code the token 'DATA'?",
    "1621": "Jump if not.",
    "1626": "However it is not possible to have 'MERGE name DATA'.",
    "1631": "Advance CH-ADD.",
    "1632": "Look in the variables area for the array.",
    "1635": "Set bit 7 of the array's name.",
    "1637": "Jump if handling an existing array.",
    "1639": "Signal 'using a new array'.",
    "1642": "Consider the value in T-ADDR and give an error if trying to SAVE or VERIFY a new array.",
    "1650": "Note: This fails to exclude simple strings.",
    "1653": "Jump forward if checking syntax.",
    "1659": "The low length byte goes into the work space; followed by the high length byte.",
    "1658": "Point to the 'low length' of the variable.",
    "1668": "Step past the length bytes.",
    "1669": "Copy the array's name.",
    "1672": "Assume an array of numbers.",
    "1676": "Jump if it is so.",
    "1678": "It is an array of characters.",
    "1679": "Save the 'type' in the first location of the header area.",
    "1682": "Save the pointer in DE.",
    "1683": "Is the next character a ')' ?",
    "1686": "Give report C if it is not.",
    "1688": "Advance CH-ADD.",
    "1689": "Move on to the next statement if checking syntax.",
    "1692": "Return the pointer to the HL register pair before jumping forward. (The pointer indicates the start of an existing array's contents.)",
    "1696": "Is the present code the token SCREEN$'.",
    "1698": "Jump if not.",
    "100": "However it is not possible to have 'MERGE name SCREEN$'.",
    "1708": "Advance CH-ADD.",
    "1703": "However it is not possible to have 'MERGE name SCREEN$'.",
    "1709": "Move on to the next statement if checking syntax.",
    "1712": "The display area and the attribute area occupy +1800 locations and these locations start at +4000;",
    "1723": "these details are passed to the header area in the work space.",
    "1729": "Jump forward.",
    "108": "Is the present code the token 'CODE'?",
    "1731": "Is the present code the token 'CODE'?",
    "1733": "Jump if not.",
    "1735": "However it is not possible to have 'MERGE name CODE'.",
    "1743": "Advance CH-ADD.",
    "1747": "Jump forward if the statement has not finished.",
    "1749": "However it is not possible to have 'SAVE name CODE' by itself.",
    "1756": "Put a zero on the calculator stack - for the 'start'.",
    "1759": "Jump forward.",
    "1761": "Fetch the first number.",
    "1765": "Is the present character a ',' or not?",
    "1767": "Jump if it is - the number was a 'starting address'.",
    "1769": "However refuse 'SAVE name CODE' that does not have a 'start' and a 'length'.",
    "1776": "Put a zero on the calculator stack.",
    "1779": "Jump forward.",
    "1781": "Advance CH-ADD.",
    "1782": "Fetch the 'length'.",
    "1785": "But move on to the next statement now if checking syntax.",
    "1788": "ompress the 'length' into the BC register pair and store it.",
    "1797": "Compress the 'starting address' into the BC register pair and store it.",
    "1806": "Transfer the 'pointer' to the HL register pair as usual.",
    "1808": "Enter the 'type' number.",
    "1812": "Rejoin the other pathways.",
    "1814": "Is the present code the token 'LINE'?",
    "1816": "Jump if it is.",
    "1818": "Move on to the next statement if checking syntax.",
    "1821": "When there are no further parameters an +80 is entered.",
    "1825": "Jump forward.",
    "1827": "However only allow 'SAVE name LINE number'.",
    "1834": "Advance CH-ADD.",
    "1835": "Pass the number to the calculator stack.",
    "1838": "Move on to the next statement if checking syntax.",
    "1841": "Compress the 'line number' into the BC register pair and store it.",
    "1850": "Enter the 'type' number.",
    "1854": "The pointer to the end of the variables area.",
    "1857": "The pointer to the start of the BASIC program.",
    "1861": "Now perform the subtraction to find the length of the 'program + variables'; store the result.",
    "1870": "Repeat the operation but this time storing the length of the 'program' only.",
    "1881": "Transfer the 'pointer' to the HL register pair as usual.",
    "1882": "Jump forward when handling a SAVE command.",
    "1889": "Save the 'destination' pointer.",
    "1890": "Form in the IX register pair the base address of the 'second header area'.",
    "1895": "Make a copy of the base address.",
    "1897": "LOAD seventeen bytes.",
    "1900": "Signal 'header'.",
    "1901": "Signal 'LOAD'.",
    "1902": "Now look for a header.",
    "1905": "Retrieve the base address.",
    "1907": "Go round the loop until successful.",
    "1911": "Ensure that channel 'S' is open.",
    "1914": "Set the scroll counter.",
    "1918": "Signal 'names do not match'.",
    "1920": "Compare the 'new' type against the 'old' type.",
    "1926": "Jump if the 'types' do not match.",
    "1928": "But if they do; signal 'ten characters are to match'.",
    "1930": "Clearly the 'header' is nonsense if 'type 4 or more'.",
    "1934": "The base address of the message block.",
    "1937": "Save the C register whilst the appropriate message is printed.",
    "1944": "Make the DE register pair point to the 'new type' and the HL register pair to the 'old name'.",
    "1949": "Ten characters are to be considered.",
    "1951": "Jump forward if the match is to be against an actual name.",
    "1955": "But if the 'old name' is 'null' then signal 'ten characters already match'.",
    "1958": "Consider each character of the 'new name' in turn.",
    "1960": "Match it against the appropriate character of the 'old name'.",
    "1962": "Do not count it if it does not match.",
    "1965": "Print the 'new' character.",
    "1966": "Loop for ten characters.",
    "1968": "Accept the name only if the counter has reached zero.",
    "1972": "Follow the 'new name' with a 'carriage return'.",
    "1975": "Fetch the pointer.",
    "1976": "'SCREEN$ and CODE' are handled with VERIFY.",
    "1983": "Jump forward if using a LOAD command.",
    "1990": "Jump forward if using a MERGE command; continue with a VERIFY command.",
    "1995": "Save the 'pointer'.",
    "1996": "Fetch the 'number of bytes' as described in the 'old' header.",
    "2002": "Fetch also the number from the 'new' header.",
    "2008": "Jump forward if the 'length' is unspecified.",
    "2012": "Give report R if attempting to LOAD a larger block than has been requested.",
    "2016": "Accept equal 'lengths'.",
    "2021": "Also give report R if trying to VERIFY blocks that are of unequal size. ('Old length' greater than 'new length'.)",
    "2025": "Fetch the 'pointer', i.e. the 'start'.",
    "2026": "This 'pointer' will be used unless it is zero, in which case",
    "2030": "the 'start' found in the 'new' header will be used instead.",
    "2036": "Move the 'pointer' to the IX register pair.",
    "2039": "Jump forward unless using the VERIFY command; with the carry flag signalling 'LOAD'",
    "2047": "Signal 'VERIFY'.",
    "2048": "Signal 'accept data block only' before LOADing the block.",
    "2050": "LOAD/VERIFY a data block.",
    "2053": "Return unless an error.",
    "2056": "Fetch the 'number of bytes' as given in the 'new header'.",
    "2062": "Save the 'destination pointer'.",
    "2063": "Jump forward unless trying to LOAD a previously undeclared array.",
    "2067": "Add three bytes to the length - for the name, the low length & the high length of a new variable.",
    "2071": "Jump forward.",
    "2073": "Fetch the size of the existing 'program+variables or array'.",
    "2080": "Jump forward if no extra room will be required; taking into account the reclaiming of the presently used memory.",
    "2085": "Allow an overhead of five bytes.",
    "2089": "Move the result to the BC register pair and make the test.",
    "2094": "Fetch the 'pointer' anew.",
    "2095": "Jump forward if LOADing a BASIC program.",
    "2101": "Jump forward if LOADing a new array.",
    "2105": "Fetch the 'length' of the existing array by collecting the length bytes from the variables area.",
    "2107": "Point to its old name.",
    "2110": "Add three bytes to the BC length - one for the name and two for the 'length'.",
    "2113": "Save the IX register pair temporarily whilst the old array is reclaimed.",
    "2124": "Find the pointer to the end-marker of the variables area - the '80-byte'.",
    "2128": "Fetch the 'length' of the new array.",
    "2134": "Save this 'length'.",
    "2135": "Add three bytes - one for the name and two for the 'length'.",
    "2138": "'IX+0E' of the old header gives the name of the array.",
    "2141": "The name is saved whilst the appropriate amount of room is made available.",
    "2146": "In effect 'BC' spaces before the 'new 80-byte'.",
    "2147": "The name is entered. The 'length' is fetched and its two bytes are also entered.",
    "2153": "HL now points to the first location that is to be filled with data from the tape.",
    "2154": "This address is moved to the IX register pair;",
    "2157": "the carry flag set; 'data block' is signalled; and the block LOADed.",
    "2163": "Save the 'destination pointer'.",
    "2164": "Find the address of the end-marker of the current variables area - the '80-byte'.",
    "2168": "Save IX temporarily.",
    "2172": "Fetch the 'length' of the new data block.",
    "2178": "Keep a copy of the 'length' whilst the present program and variables areas are reclaimed.",
    "2183": "Save the pointer to the program area and the length of the new data block.",
    "2185": "Make sufficient room available for the new program and its variables.",
    "2188": "Restore the IX register pair.",
    "2192": "The system variable VARS has also to be set for the new program.",
    "2203": "If a line number was specified then it too has to be considered.",
    "2209": "Jump if 'no number'; otherwise set NEWPPC & NSPPC.",
    "2221": "Fetch the 'length'.",
    "2222": "Fetch the 'start'.",
    "2224": "Signal 'LOAD'.",
    "2225": "Signal 'data block' only.",
    "2227": "Now LOAD it.",
    "2230": "Fetch the 'length' of the data block.",
    "2236": "Save a copy of the 'length'.",
    "2237": "Now made 'length+1' locations available in the work space.",
    "2239": "Place an end-marker in the extra location.",
    "2241": "Move the 'start' pointer to the HL register pair.",
    "2242": "Fetch the original 'length'.",
    "2243": "Save a copy of the 'start'.",
    "2244": "Now set the IX register pair for the actual LOAD.",
    "2247": "Signal 'LOAD'.",
    "2248": "Signal 'data block only'.",
    "2250": "LOAD the data block.",
    "2253": "Fetch the 'start' of the new program.",
    "2254": "Initialise DE to the 'start' of the old program.",
    "2258": "Fetch a line number and test it.",
    "2261": "Jump when finished with all the lines.",
    "2263": "Fetch the high line number byte and compare it.",
    "2265": "Jump forward if it does not match but in any case advance both pointers.",
    "2269": "Repeat the comparison for the low line number bytes.",
    "2271": "Now retreat the pointers.",
    "2273": "Jump forward if the correct place has been found for a line of the new program.",
    "2275": "Otherwise find the address of the start of the next old line.",
    "2281": "Go round the loop for each of the 'old lines'.",
    "2283": "Enter the 'new line' and go round the outer loop again.",
    "2288": "Fetch each variable name in turn and test it.",
    "2290": "Return when all the variables have been considered.",
    "2293": "Return when all the variables have been considered.",
    "2294": "Fetch VARS (for the old program).",
    "2297": "Fetch each variable name and test it.",
    "2300": "Jump forward once the end marker is found. (Make an 'addition'.)",
    "2302": "Compare the names 0 st. bytes",
    "2303": "Jump forward to consider it further; returning here if it proves not to match fully.",
    "2305": "Save the new variable's name whilst the next 'old variable' is located.",
    "2310": "Restore the pointer to the DE register pair and go round the loop again.",
    "2313": "Consider bits 7, 6 & 5 only.",
    "2315": "Accept all the variable types except 'long named variables'.",
    "2319": "Make DE point to the first character of the 'new name'.",
    "2321": "Save the pointer to the 'old name'.",
    "2322": "Update both the 'old' and the 'new' pointers.",
    "2324": "Compare the two letters.",
    "2326": "Jump forward if the match fails.",
    "2328": "Go round the loop until the 'last character' is found.",
    "2331": "Fetch the pointer to the start of the 'old' name and jump forward - successful.",
    "2334": "Fetch the pointer and jump back - unsuccessful.",
    "2337": "Signal 'replace' variable.",
    "2339": "Fetch pointer to 'new' name.",
    "2340": "Switch over the registers.",
    "2341": "The zero flag is to be set if there is to be a 'replacement'; reset for an 'addition'.",
    "2342": "Signal 'handling variables'.",
    "2343": "Now make the entry.",
    "2346": "Go round the loop to consider the next new variable.",
    "2348": "Jump if handling an 'addition'.",
    "2350": "Save the flags.",
    "2351": "Save the 'new' pointer whilst the 'old' line or variable is reclaimed.",
    "2365": "Restore the flags.",
    "2366": "Save the flags.",
    "2367": "Make a copy of the 'destination' pointer.",
    "2368": "Find the length of the 'new' variable/line.",
    "2371": "Save the pointer to the 'new' variable/line.",
    "2374": "Fetch PROG - to avoid corruption.",
    "2377": "Save PROG on the stack and fetch the 'new' pointer.",
    "2378": "Save the length.",
    "2379": "Retrieve the flags.",
    "2380": "Jump forward if adding a new variable.",
    "2382": "A new line is added before the 'destination' location.",
    "2389": "Make the room for the new variable.",
    "2383": "Make the room for the new line.",
    "2387": "Jump forward.",
    "2392": "Point to the 1st new location.",
    "2393": "Retrieve the length.",
    "2394": "Retrieve PROG and store it in its correct place.",
    "2399": "Also fetch the 'new' pointer.",
    "2403": "Again save the length and the 'new' pointer.",
    "2405": "Switch the pointers and copy the 'new' variable/line into the room made for it.",
    "2408": "Fetch the 'new' pointer.",
    "2409": "Fetch the length.",
    "2410": "Save the 'old' pointer. (Points to the location after the 'added' variable/line.)",
    "2411": "Remove the variable/line from the work space",
    "2414": "Return with the 'old' pointer in the DE register pair.",
    "2416": "Save the 'pointer'.",
    "2417": "Ensure that channel 'K' is open.",
    "2422": "Signal 'first message'.",
    "2423": "Print the message - Start tape, then press any key.'",
    "2429": "Signal 'screen will require to be cleared'.",
    "2433": "Wait for a key to be pressed.",
    "2436": "Save the base address of the 'header' on the machine stack.",
    "2438": "Seventeen bytes are to be saved.",
    "2441": "Signal 'It is a header'.",
    "2442": "Send the 'header'; with a leading 'type' byte and a trailing 'parity' byte.",
    "2445": "Retrieve the pointer to the 'header'.",
    "2447": "The delay is for fifty interrupts, i.e. one second.",
    "2452": "Fetch the length of the data block that is to be SAVEd.",
    "2458": "Signal 'data block'.",
    "2460": "Fetch the 'start of block pointer' and SAVE the block.",
    "2548": "The current print position.",
    "2551": "If the code represents a printable character then jump.",
    "2556": "Print a question mark for codes in the range +00 - +05.",
    "2560": "And also for codes +18 - +1F.",
    "2564": "Base of 'control' table.",
    "2567": "Move the code to the DE register pair.",
    "2570": "Index into the table and fetch the offset.",
    "2572": "Add the offset and make an indirect jump to the appropriate subroutine.",
    "2595": "Move leftwards by one column.",
    "2596": "Accept the change unless up against the lefthand side.",
    "2607": "Go up one line.",
    "2601": "If dealing with the printer jump forward.",
    "2608": "Set column value.",
    "2610": "Test against top line. Note: This ought to be +19.",
    "2613": "Accept the change unless at the top of the screen.",
    "2615": "Unacceptable so down a line.",
    "2616": "Set to lefthand column.",
    "2618": "Make an indirect return via CL-SET & PO-STORE.",
    "2621": "Fetch P-FLAG and save it on the machine stack.",
    "2625": "Set P-FLAG to OVER 1.",
    "2629": "A 'space'.",
    "2631": "Print the character.",
    "2634": "Fetch the old value of P-FLAG.",
    "2638": "Finished. Note: The programmer has forgotten to exit via PO-STORE.",
    "2639": "Jump forward if handling the printer.",
    "2646": "Set to lefthand column.",
    "2648": "Scroll if necessary.",
    "2651": "Now down a line.",
    "2652": "Make an indirect return via CL-SET & PO-STORE.",
    "2655": "Why again?",
    "2658": "Current column number.",
    "2659": "Move rightwards by two columns and then test.",
    "2661": "The A register will be +00 or +10.",
    "2663": "Exit via PO-FILL.",
    "2665": "The character '?'.",
    "2667": "Now print this character instead.",
    "2669": "Save the first operand in TVDATA-hi and change the address of the 'output' routine to PO-CONT (+0A87).",
    "2677": "The character code will be saved in TVDATA-lo and the address of the 'output' routine changed to PO-TV-2 (+0A6D).",
    "2682": "The 'output' routine is to be changed to PO-CONT (+0A87).",
    "2685": "Save the control character code.",
    "2688": "HL will point to the 'output' routine address.",
    "2691": "Enter the new 'output' routine address and thereby force the next character code to be considered as an operand.",
    "2695": "Restore the original address for PRINT-OUT (+09F4).",
    "2701": "Fetch the control code and the first operand if there are indeed two operands.",
    "2704": "The 'last' operand and the control code are moved.",
    "2706": "Jump forward if handling INK to OVER.",
    "2711": "Jump forward if handling TAB.",
    "2713": "The line number.",
    "2714": "The column number.",
    "2715": "Reverse the column number; i.e. +00 - +1F becomes +1F - +00.",
    "2718": "Must be in range.",
    "2720": "Add in the offset to give C holding +21 - +22.",
    "2723": "Jump forward if handling the printer.",
    "2729": "Reverse the line number; i.e. +00 - +15 becomes +16 - +01.",
    "2732": "If appropriate jump forward.",
    "2735": "The range +16 - +01 becomes +17 - +02.",
    "2737": "And now +18 - +03.",
    "2738": "If printing in the lower part of the screen then consider whether scrolling is needed.",
    "2745": "Give report 5 - Out of screen, REPORT-5 if required.",
    "2751": "Return via CL-SET & PO-STORE.",
    "2754": "Fetch the first operand.",
    "2755": "The current print position.",
    "2758": "Add the current column value.",
    "2759": "Find how many 'spaces', modulo 32, are required and return if the result is zero.",
    "2763": "Use D as the counter.",
    "2764": "Suppress 'leading space'.",
    "2768": "Print 'D number' of spaces.",
    "2776": "Now finished.",
    "2777": "Print the character(s) and continue into PO-STORE.",
    "2780": "Jump forward if handling the printer.",
    "2786": "Jump forward if handling the lower part of the screen.",
    "2792": "Save the values that relate to the main part of the screen. Then return.",
    "2800": "Save the values that relate to the lower part of the screen.",
    "2811": "Then return.",
    "2812": "Save the values that relate to the printer buffer.",
    "2818": "Then return.",
    "2819": "Jump forward if handling the printer.",
    "2825": "Fetch the values relating to the main part of the screen and return if this was the intention.",
    "2845": "Fetch the values relating to the printer buffer.",
    "2837": "Otherwise fetch the values relating to the lower part of the screen.",
    "2852": "Jump forward with ordinary character codes.",
    "2856": "Jump forward with token codes and UDG codes.",
    "2860": "Move the graphic code.",
    "2861": "Construct the graphic form.",
    "2864": "HL has been disturbed so 'fetch' again.",
    "2867": "Make DE point to the start of the graphic form; i.e. MEMBOT.",
    "2870": "Jump forward to print the graphic character.",
    "2872": "This is MEMBOT.",
    "2875": "In effect call the following subroutine twice.",
    "2878": "Determine bit 0 (and later bit 2) of the graphic code.",
    "2881": "The A register will hold +00 or +0F depending on the value of the bit in the code.",
    "2883": "Save the result in C.",
    "2884": "Determine bit 1 (and later bit 3) of the graphic code.",
    "2887": "The A register will hold +00 or +F0.",
    "2889": "The two results are combined.",
    "2890": "The A register holds half the character form and has to be used four times.",
    "2894": "This is done for the upper half of the character form and then the lower.",
    "2898": "Jump forward with token codes.",
    "2902": "UDG codes are now +00 - +0F.",
    "2904": "Save the current position values on the machine stack.",
    "2905": "Fetch the base address of the UDG area and jump forward.",
    "2911": "Now print the token and return via PO-FETCH.",
    "2917": "The current position is saved.",
    "2918": "The base address of the character area is fetched.",
    "2922": "The print address is saved.",
    "2923": "This is FLAGS.",
    "2926": "Allow for a leading space",
    "2928": "Jump forward if the character is not a 'space'.",
    "2932": "But 'suppress' if it is.",
    "2934": "Now pass the character code to the HL register pair.",
    "2937": "The character code is in effect multiplied by 8.",
    "2940": "The base address of the character form is found.",
    "2941": "The current position is fetched and the base address passed to the DE register pair.",
    "2943": "Fetch the column number.",
    "2944": "Move one column rightwards.",
    "2945": "Jump forward unless a new line is indicated.",
    "2949": "Move down one line.",
    "2950": "Column number is +21.",
    "2951": "Jump forward if handling the screen.",
    "2957": "Save the base address whilst the printer buffer is emptied.",
    "2962": "Copy the new column number.",
    "2963": "Test whether a new line is being used.",
    "2965": "If it is see if the display requires to be scrolled.",
    "2969": "Save the position values and the destination address on the machine stack.",
    "2971": "Fetch P-FLAG and read bit 0.",
    "2974": "Prepare the 'OVER-mask' in the B register; i.e. OVER 0 = +00 & OVER 1 - +FF.",
    "2980": "Read bit 2 of P-FLAG and prepare the 'INVERSE-mask' in the C register; i.e. INVERSE 0 = +00 & INVERSE 1 = +FF.",
    "2984": "Set the A register to hold the 'pixel-line' counter and clear the carry flag.",
    "2987": "Jump forward if handling the screen.",
    "2993": "Signal 'printer buffer no longer empty.",
    "2997": "Set the carry flag to show that the printer is being used.",
    "2998": "Exchange the destination address with the base address before entering the loop.",
    "2999": "The carry flag is set when using the printer. Save this flag in F'.",
    "3000": "Fetch the existing 'pixel-line'.",
    "3001": "Use the 'OVER-mask' and then XOR the result with the 'pixel-line' of the character form.",
    "3003": "Finally consider the 'INVERSE-mask'.",
    "3004": "Enter the result.",
    "3005": "Fetch the printer flag and jump forward if required.",
    "3015": "Set the attribute byte only if handling the screen.",
    "3008": "Update the destination address",
    "3009": "Update the 'pixel-line' of the character form.",
    "3010": "Decrease the counter and loop back unless it is zero.",
    "3013": "Make the H register hold a correct high-address for the character area.",
    "3022": "Restore the original destination address and the position values.",
    "3024": "Decrease the column number and increase the destination address before returning.",
    "3027": "Save the printer flag again.",
    "3028": "The required increment value.",
    "3030": "Add the value and pass the result back to the E register.",
    "3032": "Fetch the flag.",
    "3033": "Jump back into the loop.",
    "3035": "The high byte of the destination address is divided by eight and ANDed with +03 to determine which third of the screen is being addressed;",
    "3039": "i.e. 00,01 or 02.",
    "3041": "The high byte for the attribute area is then formed.",
    "3044": "D holds ATTR-T, and E holds MASK-T.",
    "3048": "The old attribute value.",
    "3049": "The values of MASK-T and ATTR-R are taken into account.",
    "3052": "Jump forward unless dealing with PAPER 9.",
    "3058": "The old paper colour is ignored and depending on whether the ink colour is light or dark",
    "3064": "The new paper colour will be black (000) or white (111).",
    "3066": "Jump forward unless dealing with INK 9.",
    "3072": "The old ink colour is ignored and depending on whether the paper colour is light or dark.",
    "3078": "ink colour will be black (000) or white (111).",
    "3080": "Enter the new attribute value and return."
  },
  "PrefixComments": {
    "149": "THE TOKEN TABLE: All the tokens used by the Spectrum are expanded by reference to this table. The last code of each token is 'inverted' by having its bit 7 set.",
    "19": "Unused",
    "37": "Unused",
    "43": "Unused",
    "8": "THE 'ERROR' RESTART: The error pointer is made to point to the position of the error.",
    "16": "THE 'PRINT A CHARACTER' RESTART: The A register holds the code of the character that is to be printed.",
    "24": "THE 'COLLECT CHARACTER' RESTART: The contents of the location currently addressed by CH-ADD are fetched. A return is made if the value represents a printable character, otherwise CH-ADD is incremented and the tests repeated.",
    "32": "THE 'COLLECT NEXT CHARACTER' RESTART: As a BASIC line is interpreted, this routine is called repeatedly to step along the line.",
    "40": "THE 'CALCULATOR' RESTART: The floating point calculator is entered at CALCULATE.",
    "48": "THE 'MAKE BC SPACES' RESTART: This routine creates free locations in the work space. The number of locations is determined by the current contents of the BC register pair.",
    "56": "THE 'MASKABLE INTERRUPT' ROUTINE: The real time clock is incremented and the keyboard scanned whenever a maskable interrupt occurs.",
    "3082": "THE 'MESSAGE PRINTING' SUBROUTINE: This subroutine is used to print messages and tokens. The A register holds the 'entry number' of the message or token in a table. The DE register pair holds the base address of the table.",
    "3088": "Enter here when expanding token codes.",
    "3092": "The table is searched and the correct entry printed.",
    "3117": "Now consider whether a 'trailing space' is required.",
    "3106": "The characters of the message/token are printed in turn.",
    "13147": "THE 'CALCULATE' SUBROUTINE: This subroutine is used to perform floating-point calculations. These can be considered to be of three types: I) Binary operations, e.g. addition, where two numbers in floating-point form are added together to give one 'last value'. II) Unary operations, e.g. sin, where the 'last value' is changed to give the appropriate function result as a new 'last value'. III) Manipulatory operations, e.g. st-mem-0, where the 'last value' is copied to the first five bytes of the calculator's memory area.",
    "13015": "THE TABLE OF ADDRESSES: This second table is a look-up table of the addresses of the sixty-six operational subroutines of the calculator. The offsets used to index into the table are derived either from the operation codes used in SCANNING, see 2734, etc., or from the literals that follow a RST 0028 instruction.",
    "12997": "THE TABLE OF CONSTANTS: This first table holds the five useful and frequently needed numbers zero, one, a half, a half of pi and ten. The numbers are held in a condensed form which is expanded by the STACK LITERALS subroutine, see below, to give the required floating-point form.",
    "13218": "THE 'SINGLE OPERATION' SUBROUTINE: (Offset 3B: 'fp-calc-2') This subroutine is only called from SCANNING at 2757 hex and is used to perform a single arithmetic operation. The offset that specifies which operation is to be performed is supplied to the calculator in the B register and subsequently transferred to the system variable BREG. The effect of calling this subroutine is essentially to make a jump to the appropriate subroutine for the single operation.",
    "13225": "THE 'TEST 5-SPACES' SUBROUTINE: This subroutine tests whether there is sufficient room in memory for another 5-byte floating-point number to be added to the calculator stack.",
    "13236": "THE 'STACK NUMBER' SUBROUTINE: This subroutine is called by BEEP and SCANNING twice to copy STKEND to DE, move a floating-point number to the calculator stack, and reset STKEND from DE. It calls 'MOVE-FP' to do the actual move.",
    "13248": "THE 'MOVE A FLOATING-POINT NUMBER' SUBROUTINE: (Offset 31: 'duplicate') This subroutine moves a floating-point number to the top of the calculator stack (3 cases) or from the top of the stack to the calculator's memory area (1 case). It is also called through the calculator when it simply duplicates the number at the top of the calculator stack, the 'last value', thereby extending the stack by five bytes.",
    "13254": "THE 'STACK LITERALS' SUBROUTINE: This subroutine places on the calculator stack, as a 'last value', the floating-point number supplied to it as 2, 3, 4 or 5 literals. In each case, the first literal supplied is divided by Hex.40, and the integer quotient plus 1 determines whether 1, 2, 3 or 4 further literals will be taken from the source to form the mantissa of the number. Any unfilled bytes of the five bytes that go to form a 5-byte floating-point number are set to zero. The first literal is also used to determine the exponent, after reducing mod Hex.40, unless the remainder is zero, in which case the second literal is used, as it stands, without reducing mod Hex.40. In either case, Hex.50 is added to the literal, giving the augmented exponent byte, e (the true exponent e' plus Hex.80). The rest of the 5 bytes are stacked, including any zeros needed, and the subroutine returns.",
    "13303": "THE 'SKIP CONSTANTS' SUBROUTINE: This subroutine is entered with the HL register pair holding the base address of the calculator's table of constants and the A register holding a parameter that shows which of the five constants is being requested.",
    "13318": "THE 'MEMORY LOCATION' SUBROUTINE: This subroutine finds the base address for each five byte portion of the calculator's memory area to or from which a floating-point number is to be moved from or to the calculator stack. It does this operation by adding five times the parameter supplied to the base address for the area which is held in the HL register pair. Note that when a FOR-NEXT variable is being handled then the pointers are changed so that the variable is treated as if it were the calculator's memory area (see address 1D20).",
    "13327": "THE 'GET FROM MEMORY AREA' SUBROUTINE: (Offsets E0 to E5: 'get-mem-0' to 'get-mem-5') This subroutine is called using the literals E0 to E5 and the parameter derived from these literals is held in the A register. The subroutine calls MEMORY LOCATION to put the required source address into the HL register pair and MOVE A FLOATING-POINT NUMBER to copy the five bytes involved from the calculator's memory area to the top of the calculator stack to form a new 'last value'.",
    "13339": "THE 'STACK A CONSTANT' SUBROUTINE: (offsets A0 to A4: 'stk-zero','stk-one','stk-half','stk-pi/2' & 'stk-ten') This subroutine uses SKIP CONSTANTS to find the base address of the requested constants from the calculator's table of constants and then calls STACK LITERALS, entering at STK-CONST, to make the expanded form of the constant the 'last value' on the calculator stack.",
    "13357": "THE 'STORE IN MEMORY AREA' SUBROUTINE: (Offsets C0 to C5: 'st-mem-0' to 'st-mem-5') This subroutine is called using the literals C0 to C5 and the parameter derived from these literals is held in the A register. This subroutine is very similar to the GET FROM MEMORY subroutine but the source and destination pointers are exchanged.",
    "13372": "THE 'EXCHANGE' SUBROUTINE: (Offset 01: 'exchange') This binary operation 'exchanges' the first number with the second number, i.e. the topmost two numbers on the calculator stack are exchanged.",
    "13418": "THE 'ABSOLUTE MAGNITUDE' FUNCTION: (Offset 2A: 'abs') This subroutine performs its unary operation by ensuring that the sign bit of a floating-point number is reset.",
    "13428": "'ABS' enters here.",
    "13443": "The 'integer case' does a similar operation with the sign byte.",
    "13422": "THE 'UNARY MINUS' OPERATION: (Offset 1B: 'negate') This subroutine performs its unary operation by changing the sign of the 'last value' on the calculator stack. Zero is simply returned unchanged. Full five byte floating-point numbers have their sign bit manipulated so that it ends up reset (for 'abs') or changed (for 'negate'). 'Small integers' have their sign byte set to zero (for 'abs') or changed (for 'negate').",
    "13458": "THE 'SIGNUM' FUNCTION: (Offset 29: 'sgn') This subroutine handles the function SGN X and therefore returns a 'last value' of 1 if X is positive, zero if X is zero and -1 if X is negative.",
    "13477": "THE 'IN' FUNCTION: (Offset 2C: 'in') This subroutine handles the function IN X. It inputs at processor level from port X, loading BC with X and performing the instruction IN A,(C).",
    "13484": "THE 'PEEK' FUNCTION: (Offset 2B: 'peek') This subroutine handles the function PEEK X. The 'last value' is unstacked by calling FIND-INT2 and replaced by the value of the contents of the required location.",
    "13491": "THE 'USR' FUNCTION: (Offset 2D: 'usr-no') This subroutine ('USR number' as distinct from 'USR string') handles the function USR X, where X is a number. The value of X is obtained in BC, a return address is stacked and the machine code is executed from location X.",
    "13500": "THE 'USR-STRING' FUNCTION: (Offset 19: 'usr-$') This subroutine handles the function USR X$, where X$ is a string. The subroutine returns in BC the address of the bit pattern for the user-defined graphic corresponding to X$. It reports error A if X$ is not a single letter between a and u or a user-defined graphic.",
    "13543": "REPORT A - Invalid argument.",
    "13545": "THE 'TEST-ZERO' SUBROUTINE: This subroutine is called at least nine times to test whether a floating-point number is zero. This test requires that the first four bytes of the number should each be zero. The subroutine returns with the carry flag set if the number was in fact zero.",
    "13561": "THE 'GREATER THAN ZERO' OPERATION: (Offset 37: 'greater-0') This subroutine returns a 'last value' of one if the present 'last value' is greater than zero and zero otherwise. It is also used by other subroutines to 'jump on plus'.",
    "13569": "THE 'NOT' FUNCTION: (Offset 30: 'not') This subroutine returns a 'last value' of one if the present 'last value' is zero and zero otherwise. It is also used by other subroutines to 'jump on zero'.",
    "13574": "THE 'LESS THAN ZERO' OPERATION: (Offset 36: 'less-0') This subroutine returns a 'last value' of one if the present 'last value' is less than zero and zero otherwise. It is also used by other subroutines to 'jump on minus'.",
    "13579": "THE 'ZERO OR ONE' SUBROUTINE: This subroutine sets the 'last value' to zero if the carry flag is reset and to one if it is set. When called from 'E-TO-FP' however it creates the zero or one not on the stack but in mem-0.",
    "13595": "THE 'OR' OPERATION: (Offset 07: 'or') This subroutine performs the binary operation 'X OR Y' and returns X if Y is zero and the value 1 otherwise.",
    "13604": "THE 'NUMBER AND NUMBER' OPERATION: (Offset 08: 'no-&-no') This subroutine performs the binary operation 'X AND Y' and returns X if Y is non-zero and the value zero otherwise.",
    "13613": "THE 'STRING AND NUMBER' OPERATION: (Offset 10: 'str-&-no') This subroutine performs the binary operation 'X$ AND Y' and returns X$ if Y is non-zero and a null string otherwise.",
    "14261": "THE 'SINE' FUNCTION: This subroutine handles the function SIN X and is the third of the four routines that use SERIES GENERATOR to produce Chebyshev polynomials.",
    "14262": "Perform step #1: The argument X is reduced and in this case W = V directly.",
    "14263": "Perform step#2: The argument Z is formed, such that Z=2*W*W-1. The subroutine from now on is common to both the SINE and COSINE functions.",
    "14270": "Perform step #3: Pass to the SERIES GENERATOR the parameter '6' and the six constants required. The SERIES GENERATOR is used to return (SIN (PI*W/2))/W. ",
    "517": "THE KEY TABLES: There are six separate key tables. The final character code obtained depends on the particular key pressed and the 'mode' being used. (a) The main key table - L mode and CAPS SHIFT.",
    "556": "(b) Extended mode. Letter keys and unshifted",
    "95": "Unused",
    "83": "THE 'ERROR-2' ROUTINE: The return address to the interpreter points to the 'DEFB' that signifies which error has occurred. This 'DEFB' is fetched and transferred to ERR-NR. The machine stack is cleared before jumping forward to clear the calculator stack.",
    "102": "THE 'NON-MASKABLE INTERRUPT' ROUTINE: This routine is not used in the standard Spectrum but the code allows for a system reset to occur following activation of the NMI line. The system variable at 5CB0, named here NMIADD, has to have the value zero for the reset to occur.",
    "116": "THE 'CH-ADD+1' SUBROUTINE: The address held in CH-ADD is fetched, incremented and restored. The contents of the location now addressed by CH-ADD is fetched. The entry points of TEMP-PTR1 and TEMP-PTR2 are used to set CH-ADD for a temporary period.",
    "125": "THE 'SKIP-OVER' SUBROUTINE: The value brought to the subroutine in the A register is tested to see if it is printable. Various special codes lead to HL being incremented once, or twice, and CH-ADD amended accordingly.",
    "608": "(d) Control codes. Digit keys and CAPS SHIFT.",
    "582": "(c) Extended mode. Letter keys and either shift.",
    "618": "(e) Symbol code. Letter keys and symbol shift.",
    "644": "(f) Extended mode. Digit keys and symbol shift.",
    "654": "THE 'KEYBOARD SCANNING' SUBROUTINE: This very important subroutine is called by both the main keyboard subroutine and the INKEY$ routine (in SCANNING). In all instances the E register is returned with a value in the range of +00 to +27, the value being different for each of the forty keys of the keyboard, or the value +FF, the no-key. The D register is returned with a value that indicates which single shift key is being pressed. If both shift keys are being pressed then the D and E registers are returned with the values for the CAPS SHIFT and SYMBOL SHIFT keys respectively. If no keys is being pressed then the DE register pair is returned holding +FFFF. The zero flag is returned reset if more than two keys are being pressed, or neither key of a pair of keys is a shift key.",
    "662": "Now enter a loop. Eight passes are made with each pass having a different initial key value and scanning a different line of five keys. (The first line is CAPS SHIFT, Z, X, C, V.)",
    "688": "Four tests are now made.",
    "703": "THE 'KEYBOARD' SUBROUTINE: This subroutine is called on every occasion that a maskable interrupt occurs. In normal operation this will happen once every 20 ms. The purpose of this subroutine is to scan the keyboard and decode the key value. The code produced will, if the 'repeat' status allows it, be passed to the system variable LAST-K. When a code is put into this system variable bit 5 of FLAGS is set to show that a 'new' key has been pressed.",
    "707": "A double system of 'KSTATE system variables' (KSTATE0 - KSTATE 3 and KSTATE4 - KSTATE7) is used from now on. The two sets allow for the detection of a new key being pressed (using one set) whilst still within the 'repeat period' of the previous key to have been pressed (details in the other set). A set will only become free to handle a new key if the key is held down for about 1/10 th. of a second. i.e. Five calls to KEYBOARD.",
    "721": "After considering the first set change the pointer and consider the second set.",
    "728": "Return now if the key value indicates 'no-key' or a shift key only.",
    "732": "A key stroke that is being repeated (held down) is now separated from a new key stroke.",
    "745": "But a new key will not be accepted unless one of the sets of KSTATE system variables is 'free'.",
    "753": "The new key is to be accepted. But before the system variable LAST-K can be filled, the KSTATE system variables, of the set being used, have to be initialised to handle any repeats and the key's code has to be decoded.",
    "764": "The decoding of a 'main code' depends upon the present state of MODE, bit 3 of FLAGS and the 'shift byte'.",
    "784": "THE 'REPEATING KEY' SUBROUTINE: A key will 'repeat' on the first occasion after the delay period - REPDEL (normally 0.7 secs.) and on subsequent occasions after the delay period - REPPER (normally 0.1 secs.).",
    "798": "THE 'K-TEST' SUBROUTINE: The key value is tested and a return made if 'no-key' or 'shift-only'; otherwise the 'main code' for that key is found.",
    "812": "The 'main code' is found by indexing into the main key table.",
    "819": "THE 'KEYBOARD DECODING' SUBROUTINE: This subroutine is entered with the 'main code' in the E register, the value of FLAGS in the D register, the value of MODE in the C register and the 'shift byte' in the B register. By considering these four values and referring, as necessary, to the six key tables a 'final code' is produced. This is returned in the A register.",
    "830": "Only 'graphics' mode remains and the 'final code' for letter keys in graphics mode is computed from the 'main code'.",
    "833": "Letter keys in extended mode are considered next.",
    "842": "Key tables 'b-f' are all served by the following look-up routine. In all cases a 'final code' is found and returned.",
    "847": "Letter keys in 'K', 'L' or 'C' modes are now considered. But first the special SYMBOL SHIFT codes have to be dealt with.",
    "868": "The 'final code' values for tokens are found by adding +A5 to the 'main code'.",
    "871": "Next the digit keys; and SPACE, ENTER & both shifts; are considered.",
    "891": "The digit keys '0' to '7' in extended mode are to give either a 'paper colour code' or an 'ink colour code' depending on the use of the CAPS SHIFT.",
    "898": "The digit keys '8' and '9' are to give 'BRIGHT' & 'FLASH' codes.",
    "905": "The digit keys in graphics mode are to give the block graphic characters (+80 to +8F), the GRAPHICS code (+0F) and the DELETE code (+0C).",
    "925": "Finally consider the digit keys in 'K', 'L' & 'C' modes.",
    "934": "The codes for the various digit keys and SYMBOL SHIFT can now be found.",
    "949": "THE 'BEEPER' SUBROUTINE: This subroutine is entered with the DE register pair holding the value 'f*t', where a note of given frequency 'f' is to have a duration of 't' seconds, and the HL register pair holding a value equal to the number of T states in the 'timing loop' divided by '4'. i.e. For the note 'middle C' to be produced for one second DE holds +0105 (INT(261.3 * 1)) and HL holds +066A (derived from 6,689/4 - 30.125).",
    "977": "Now enter the sound generation loop. 'DE' complete passes are made, i.e. a pass for each cycle of the note. The HL register holds the 'length of the timing loop' with '16' T states being used for each '1' in the L register and '1,024' T states for each '1' in the H register.",
    "991": "The loudspeaker is now alternately activated and deactivated.",
    "1001": "After a full cycle the DE register pair is tested.",
    "1010": "The parameters for the second half-cycle are set up.",
    "1014": "Upon completion of the 'beep' the maskable interrupt has to be enabled.",
    "1016": "THE 'BEEP' COMMAND ROUTINE: The subroutine is entered with two numbers on the calculator stack. The topmost number represents the 'pitch' of the note and the number underneath it represents the 'duration'.",
    "1031": "Now perform several tests on I, the integer part of the 'pitch'.",
    "1061": "Note: The range +70 to +127 will be rejected later on. The correct frequency for the 'pitch' i can now be found.",
    "1077": "Now the fractional part of the 'pitch' can be taken into consideration.",
    "1083": "The final frequency f is found by modifying the 'last value' according to the octave number.",
    "1098": "The number of complete cycles in the 'beep' is given by 'f*t' so this value is now found.",
    "1115": "Note: The value '437,500/f' gives the 'half-cycle' length of the note and reducing it by '30.125' allows for '120.5' T states in which to actually produce the note and adjust the counters etc. The values can now be transferred to the required registers.",
    "1119": "Note: If the timing loop value is too large then an error will occur (returning via ERROR-1); thereby excluding 'pitch' values of '+70 to +127'.",
    "1125": "However before making the 'beep' test the value 'f*t'.",
    "1132": "Report B - integer out of range",
    "1194": "THE 'PROGRAM NAME' SUBROUTINE (ZX81): The following subroutine applies to the ZX81 and was not removed when the program was rewritten for the SPECTRUM.",
    "1218": "THE 'SA-BYTES' SUBROUTINE: This subroutine is called to SAVE the header information (from 09BA) and later the actual program/data block (from 099E).",
    "1240": "A loop is now entered to create the pulses of the leader. Both the 'MIC on' and the 'MIC off' pulses are 2,168 T states in length. The colour of the border changes from RED to CYAN with each 'edge'. Note: An 'edge' will be a transition either from 'on' to 'off', or from 'off' to 'on'.",
    "1256": "A sync pulse is now sent.",
    "1270": "The header v. program/data flag will be the first byte to be SAVEd.",
    "1278": "The byte SAVEing loop is now entered. The first byte to be SAVEd is the flag; this is followed by the actual data byte and the final byte sent is the parity byte that is built up by considering the values of all the earlier bytes.",
    "1294": "When it is time to send the 'parity' byte then it is transferred to the L register for SAVEing.",
    "1297": "The following inner loop produces the actual pulses. The loop is entered at SA-BIT-1 with the type of the bit to be SAVEd indicated by the carry flag. Two passes of the loop are made for each bit thereby making an 'off pulse' and an 'on pulse'. The pulses for a reset bit are shorter by 855 T states.",
    "1317": "The '8 bit loop' is entered initially with the whole byte in the L register and the carry flag set. However it is re-entered after each bit has been SAVEd until the point is reached when the 'marker' passes to the carry flag leaving the L register empty.",
    "1340": "Note: A reset bit will give a 'MIC off' pulse of 855 T states followed by a 'MIC on' pulse of 855 T states. Whereas a Set bit will give pulses of exactly twice as long. Note also that there are no gaps either between the sync pulse and the first bit of the flag, or between bytes.",
    "1343": "THE 'SA/LD-RET' SUBROUTINE: This subroutine is common to both SAVEing and LOADing. The border is set to its original colour and the BREAK key tested for a last time.",
    "1362": "Report D - BREAK-CONT repeats",
    "1364": "Continue here.",
    "1366": "THE 'LD-BYTES' SUBROUTINE: This subroutine is called to LOAD the header information (from 07BE) and later LOAD, or VERIFY, an actual block of data (from 0802).",
    "2465": "THE CASSETTE MESSAGES: Each message is given with the last character inverted (+80 hex.).",
    "2548": "THE 'PRINT-OUT' ROUTINES: All of the printing to the main part of the screen, the lower part of the screen and the printer is handled by this set of routines.",
    "2577": "THE 'CONTROL CHARACTER' TABLE",
    "1387": "The first stage of reading a tape involves showing that a pulsing signal actually exist (i.e. 'On/off' or 'off/on' edges.)",
    "1648": "Report 2 - Variable not found",
    "1393": "The next stage involves waiting a while and then showing that the signal is still pulsing.",
    "1408": "Now accept only a 'leader signal'.",
    "1423": "After the leader come the 'off' and 'on' part's of the sync pulse.",
    "1439": "The bytes of the header or the program/data block can now be LOADed or VERIFied. But the first byte is the type flag.",
    "1449": "The byte LOADing loop is used to fetch the bytes one at a time. The flag byte is first. This is followed by the data bytes and the last byte is the 'parity' byte.",
    "1469": "If a data block is being verified then the freshly loaded byte is tested against the original byte.",
    "1474": "A new byte can now be collected from the tape.",
    "1482": "The 'LD-8-BITS' loop is used to build up a byte in the L register.",
    "1496": "The 'parity matching' byte has to be updated with each new byte.",
    "1499": "Passes round the loop are made until the 'counter' reaches zero. At that point the 'parity matching' byte should be holding zero.",
    "1507": "THE 'LD-EDGE-2' AND 'LD-EDGE-1' SUBROUTINES: These two subroutines form the most important part of the LOAD/VERIFY operation. The subroutines are entered with a timing constant in the B register, and the previous border colour and 'edge-type' in the C register. The subroutines return with the carry flag set if the required number of 'edges' have been found in the time allowed; and the change to the value in the B register shows just how long it took to find the 'edge(s)'. The carry flag will be reset if there is an error. The zero flag then signals 'BREAK pressed' by being reset, or 'time-up' by being set. The entry point LD-EDGE-2 is used when the length of a complete pulse is required and LD-EDGE-1 is used to find the time before the next 'edge'.",
    "1517": "The sampling loop is now entered. The value in the B register is incremented for each pass; 'time-up' is given when B reaches zero.",
    "1530": "A new 'edge' has been found within the time period allowed for the search. So change the border colour and set the carry flag.",
    "1541": "THE 'SAVE, LOAD, VERIFY & MERGE' COMMAND ROUTINES: The entry point SAVE-ETC is used for all four commands. The value held in T-ADDR however distinguishes between the four commands. The first part of the following routine is concerned with the construction of the 'header information' in the work space.",
    "1602": "Report F - Invalid file name",
    "1604": "Continue to handle the name of the program.",
    "1611": "The name is now transferred to the work space (second location onwards).",
    "1618": "The many different parameters, if any, that follow the command are now considered. Start by handling 'xxx \"name\" DATA'.",
    "1650": "Continue with the handling of an existing array.",
    "1669": "The next part is common to both 'old' and 'new' arrays. Note: Syntax path error.",
    "1682": "The last part of the statement is examined before joining the other pathways.",
    "1696": "Now consider 'SCREEN$'.",
    "1731": "Now consider 'CODE'.",
    "1761": "Look for a 'starting address'.",
    "1781": "Fetch the 'length' as it was specified.",
    "1785": "The parameters are now stored in the header area of the work space.",
    "1808": "'SCREEN$' and 'CODE' are both of type 3.",
    "1814": "Now consider 'LINE'; and 'no further parameters'.",
    "1827": "Fetch the 'line number' that must follow 'LINE'.",
    "1850": "'LINE' and 'no further parameters' are both of type 0.",
    "1854": "The parameters that describe the program, and its variables, are found and stored in the header area of the work space.",
    "1882": "In all cases the header information has now been prepared. The location 'IX+00' holds the type number. Locations 'IX+01 to IX+0A' holds the name (+FF in 'IX+01' if null). Locations 'IX+0B & IX+0C' hold the number of bytes that are to be found in the 'data block'. Locations 'IX+0D to IX+10' hold a variety of parameters whose exact interpretation depends on the 'type'. The routine continues with the first task being to separate SAVE from LOAD, VERIFY and MERGE.",
    "1889": "In the case of a LOAD, VERIFY or MERGE command the first seventeen bytes of the 'header area' in the work space hold the prepared information, as detailed above; and it is now time to fetch a 'header' from the tape.",
    "1895": "Now enter a loop; leaving it only when a 'header' has been LOADed.",
    "1909": "The new 'header' is now displayed on the screen but the routine will only proceed if the 'new' header matches the 'old' header.",
    "1934": "The appropriate message - 'Program:', 'Number array:', 'Character array:' or 'Bytes:' is printed.",
    "1942": "The 'new name' is printed and as this is done the 'old' and the 'new' names are compared.",
    "1958": "A loop is entered to print the characters of the 'new name'. The name will be accepted if the 'counter' reaches zero, at least.",
    "1975": "The correct header has been found and the time has come to consider the three commands LOAD, VERIFY, & MERGE separately.",
    "1995": "THE 'VERIFY' CONTROL ROUTINE: The verification process involves the LOADing of a block of data, a byte at a time, but the bytes are not stored - only checked. This routine is also used to LOAD blocks of data that have been described with 'SCREEN$ & CODE'.",
    "2025": "The routine continues by considering the 'destination pointer'.",
    "2036": "The VERIFY/LOAD flag is now considered and the actual LOAD made.",
    "2050": "THE 'LOAD A DATA BLOCK' SUBROUTINE: This subroutine is common to all the 'LOADing' routines. In the case of LOAD & VERIFY it acts as a full return from the cassette handling routines but in the case of MERGE the data block has yet to be 'MERGEd'.",
    "2054": "Report R - Tape loading error",
    "2056": "THE 'LOAD' CONTROL ROUTINE: This routine controls the LOADing of a BASIC program, and its variables, or an array.",
    "2073": "Consider now if there is enough room in memory for the new data block.",
    "2085": "Make the actual test for room.",
    "2094": "Now deal with the LOADing of arrays.",
    "2124": "Space is now made available for the new array - at the end of the present variables area.",
    "2163": "Now deal with the LOADing of a BASIC program and its variables.",
    "2221": "The data block can now be LOADed.",
    "2230": "THE 'MERGE' CONTROL ROUTINE: There are three main parts to this routine. 1) LOAD the data block into the work space. 2) MERGE the lines of the new program into the old program. 3) MERGE the new variables into the old variables. Start therefore with the LOADing of the data block.",
    "2253": "The lines of the new program are MERGEd with the lines of the old program.",
    "2258": "Enter a loop to deal with the lines of the new program.",
    "2263": "Now enter an inner loop to deal with the lines of the old program.",
    "2288": "In a similar manner the variables of the new program are MERGEd with the variables of the old program. A loop is entered to deal with each of the new variables in turn.",
    "2297": "Now enter an inner loop to search the existing variables area.",
    "2313": "The old and new variables match with respect to their first bytes but variables with long names will need to be matched fully.",
    "2322": "Enter a loop to compare the letters of the long names.",
    "2337": "Come here if the match was found.",
    "2339": "And here if not. (A holds +80 - variable to be 'added'.)",
    "2348": "THE 'MERGE A LINE OR A VARIABLE' SUBROUTINE: This subroutine is entered with the following parameters: Carry flag reset - MERGE a BASIC line. Carry flag set - MERGE a variable. Zero flag resset - It will be an 'addition'. Zero flag set - It is a 'replacement'. HL points to the start of the new entry. DE points to where it is to MERGE.",
    "2366": "The new entry can now be made.",
    "2408": "Fetch the 'new' pointer.",
    "2416": "THE 'SAVE' CONTROL ROUTINE: The operation of SAVing a program or a block of data is very straightforward.",
    "2436": "Upon receipt of a keystroke the 'header' is saved.",
    "2520": "There follows a short delay before the program/data block is SAVEd.",
    "2445": "There follows a short delay before the program/data block is SAVEd.",
    "2595": "THE 'CURSOR LEFT' SUBROUTINE: The subroutine is entered with the B register holding the current line number and the C register with the current column number.",
    "2621": "THE 'CURSOR RIGHT' SUBROUTINE: This subroutine performs an operation identical to the BASIC statement – PRINT OVER 1;CHR$ 32;",
    "2639": "THE 'CARRIAGE RETURN' SUBROUTINE: If the printing being handled is going to the printer then a carriage return character leads to the printer buffer being emptied. If the printing is to the screen then a test for 'scroll?' is made before decreasing the line number.",
    "1455": "THE 'PRINT COMMA' SUBROUTINE: The current column value is manipulated and the A register set to hold +00 (for TAB 0) or +10 (for TAB 16).",
    "2655": "THE 'PRINT COMMA' SUBROUTINE: The current column value is manipulated and the A register set to hold +00 (for TAB 0) or +10 (for TAB 16).",
    "2665": "THE 'PRINT A QUESTION MARK' SUBROUTINE: A question mark is printed whenever an attempt is made to print an unprintable code.",
    "2669": "THE 'CONTROL CHARACTERS WITH OPERANDS' ROUTINE: The control characters from INK to OVER require a single operand whereas the control characters AT & TAB are required to be followed by two operands. The present routine leads to the control character code being saved in TVDATA-lo, the first operand in TVDATA-hi or the A register if there is only a single operand required, and the second operand in the A register.",
    "2677": "Enter here when handling the characters AT & TAB.",
    "2682": "Enter here when handling the colour items - INK to OVER.",
    "2688": "The current 'output' routine address is changed temporarily.",
    "2695": "Once the operands have been collected the routine continues.",
    "2713": "Now deal with the AT control character.",
    "2754": "And the TAB control character.",
    "2777": "PRINTABLE CHARACTER CODES: The required character (or characters) is printed by calling PO-ANY followed by PO-STORE.",
    "2780": "THE 'POSITION STORE' SUBROUTINE: The new position's 'line & column' values and the 'pixel' address are stored in the appropriate system variables.",
    "2819": "The current position's parameters are fetched from the appropriate system variables.",
    "2852": "THE 'PRINT ANY CHARACTER(S)' SUBROUTINE: Ordinary character codes, token codes and user-defined graphic codes, and graphic codes are dealt with separately.",
    "2872": "Graphic characters are constructed in an Ad Hoc manner in the calculator's memory area; i.e. MEM-0 & MEM-1.",
    "2898": "Token codes and user-defined graphic codes are now separated.",
    "2917": "The required character form is identified.",
    "2943": "THE 'PRINT ALL CHARACTERS' SUBROUTINE: This subroutine is used to print all '8*8' bit characters. On entry the DE register pair holds the base address of the character form, the HL register the destination address and the BC register pair the current 'line & column' values.",
    "2969": "Now consider the present state of INVERSE & OVER",
    "2999": "The character can now be printed. Eight passes of the loop are made - one for each 'pixel-line'.",
    "3013": "Once the character has been printed the attribute byte is to set as required.",
    "3027": "When the printer is being used the destination address has to be updated in increments of +20.",
    "3035": "The appropriate attribute byte is identified and fetched. The new value is formed by manipulating the old value, ATTR-T, MASK-T and P-FLAG. Finally this new value is copied to the attribute area."
  },
  "Literals": {
    "1218": [
      "$SaveBytesRoutineAddress"
    ],
    "0": [
      "$SaveBytesResumeAddress"
    ],
    "1388": [
      "$LoadBytesRoutineAddress"
    ],
    "1506": [
      "$LoadBytesResumeAddress"
    ],
    "1462": [
      "$LoadBytesInvalidHeaderAddress"
    ],
    "149": [
      "$TokenTableAddress",
      "TOKEN_TABLE"
    ],
    "91": [
      "$TokenCount"
    ],
    "165": [
      "$TokenOffset"
    ],
    "23645": [
      "CH_ADD"
    ],
    "23647": [
      "X_PTR"
    ],
    "125": [
      "SKIP_OVER"
    ],
    "23649": [
      "WORKSPC"
    ],
    "23672": [
      "FRAMES"
    ],
    "23655": [
      "BREG"
    ],
    "23653": [
      "STKEND"
    ],
    "13015": [
      "FP_OP_ADDR"
    ],
    "13157": [
      "RE_ENTRY"
    ],
    "23654": [
      "STK_END_hi"
    ],
    "23656": [
      "MEM"
    ],
    "12997": [
      "stk_zero_const"
    ],
    "11563": [
      "STACK_BC"
    ],
    "23675": [
      "UDG"
    ],
    "23613": [
      "ERR_SP"
    ],
    "23728": [
      "NMI_ADD"
    ],
    "23552": [
      "KSTATE0"
    ],
    "23556": [
      "KSTATE4"
    ],
    "23561": [
      "REPDEL"
    ],
    "23560": [
      "LAST_K"
    ],
    "23562": [
      "REPPER"
    ],
    "23624": [
      "BORDCR"
    ],
    "23698": [
      "MEMBOT"
    ],
    "23668": [
      "T_ADDR_lo"
    ],
    "23641": [
      "E_LINE"
    ],
    "23635": [
      "PROG"
    ],
    "23627": [
      "VARS"
    ],
    "23618": [
      "NEWPPC"
    ],
    "23697": [
      "P_FLAG"
    ],
    "23567": [
      "TVDATA_hi"
    ],
    "23566": [
      "TVDATA_lo"
    ],
    "23633": [
      "CURCHL"
    ],
    "23688": [
      "S_POSN"
    ],
    "23684": [
      "DF_CC"
    ],
    "23690": [
      "ECHO_E"
    ],
    "23682": [
      "DF_CCL"
    ],
    "23686": [
      "P_POSN"
    ],
    "23606": [
      "CHARS"
    ],
    "23611": [
      "FLAGS"
    ],
    "23695": [
      "ATTR_T"
    ]
  },
  "LiteralReplacements": {
    "8": "CH_ADD",
    "11": "X_PTR",
    "24": "CH_ADD",
    "49": "WORKSPC",
    "62": "FRAMES",
    "58": "FRAMES",
    "3088": "TOKEN_TABLE",
    "13151": "BREG",
    "13157": "STKEND",
    "13198": "FP_OP_ADDR",
    "13207": "RE_ENTRY",
    "13213": "STK_END_hi",
    "13219": "BREG",
    "13236": "STKEND",
    "13243": "STKEND",
    "13328": "MEM",
    "13343": "stk_zero_const",
    "13359": "MEM",
    "13494": "STACK_BC",
    "13531": "UDG",
    "116": "CH_ADD",
    "120": "CH_ADD",
    "88": "ERR_SP",
    "104": "NMI_ADD",
    "145": "CH_ADD",
    "707": "KSTATE0",
    "722": "KSTATE4",
    "732": "KSTATE0",
    "739": "KSTATE4",
    "759": "REPDEL",
    "776": "LAST_K",
    "790": "REPPER",
    "812": "KEY_TABLE_L",
    "839": "KEY_TABLE_L",
    "961": "BE_IX_P3",
    "967": "BORDCR",
    "1031": "MEMBOT",
    "1071": "SEMI_TONE",
    "1218": "SA_LD_RET",
    "1344": "BORDCR",
    "1374": "SA_LD_RET",
    "1542": "T_ADDR_lo",
    "1547": "T_ADDR_lo",
    "1561": "T_ADDR_lo",
    "1596": "T_ADDR_lo",
    "1642": "T_ADDR_lo",
    "1623": "T_ADDR_lo",
    "1735": "T_ADDR_lo",
    "1749": "T_ADDR_lo",
    "1769": "T_ADDR_lo",
    "1827": "T_ADDR_lo",
    "1854": "E_LINE",
    "1857": "PROG",
    "1870": "VARS",
    "1983": "T_ADDR_lo",
    "2039": "T_ADDR_lo",
    "2113": "X_PTR",
    "2120": "X_PTR",
    "2124": "E_LINE",
    "2164": "E_LINE",
    "2168": "X_PTR",
    "2188": "X_PTR",
    "2200": "VARS",
    "2214": "NEWPPC",
    "2254": "PROG",
    "2294": "VARS",
    "2351": "X_PTR",
    "2362": "X_PTR",
    "2371": "X_PTR",
    "2374": "PROG",
    "2395": "PROG",
    "2399": "X_PTR",
    "2621": "P_FLAG",
    "2635": "P_FLAG",
    "2672": "TVDATA_hi",
    "2685": "TVDATA_lo",
    "2688": "CURCHL",
    "2701": "TVDATA_lo",
    "2792": "S_POSN",
    "2796": "DF_CC",
    "2800": "ECHO_E",
    "2804": "DF_CCL",
    "2808": "P_POSN",
    "2825": "S_POSN",
    "2829": "DF_CC",
    "2837": "ECHO_E",
    "2841": "P_POSN",
    "2867": "MEMBOT",
    "2872": "MEMBOT",
    "2905": "UDG",
    "2918": "CHARS",
    "2923": "FLAGS",
    "2971": "P_FLAG",
    "3044": "ATTR_T"
  },
  "MemorySections": [
    {
      "StartAddress": 0,
      "EndAddress": 18,
      "SectionType": 1
    },
    {
      "StartAddress": 19,
      "EndAddress": 23,
      "SectionType": 2
    },
    {
      "StartAddress": 24,
      "EndAddress": 36,
      "SectionType": 1
    },
    {
      "StartAddress": 37,
      "EndAddress": 39,
      "SectionType": 2
    },
    {
      "StartAddress": 40,
      "EndAddress": 42,
      "SectionType": 1
    },
    {
      "StartAddress": 43,
      "EndAddress": 47,
      "SectionType": 2
    },
    {
      "StartAddress": 48,
      "EndAddress": 94,
      "SectionType": 1
    },
    {
      "StartAddress": 95,
      "EndAddress": 101,
      "SectionType": 2
    },
    {
      "StartAddress": 102,
      "EndAddress": 148,
      "SectionType": 1
    },
    {
      "StartAddress": 149,
      "EndAddress": 516,
      "SectionType": 2
    },
    {
      "StartAddress": 517,
      "EndAddress": 555,
      "SectionType": 2
    },
    {
      "StartAddress": 556,
      "EndAddress": 581,
      "SectionType": 2
    },
    {
      "StartAddress": 582,
      "EndAddress": 607,
      "SectionType": 2
    },
    {
      "StartAddress": 608,
      "EndAddress": 617,
      "SectionType": 2
    },
    {
      "StartAddress": 618,
      "EndAddress": 643,
      "SectionType": 2
    },
    {
      "StartAddress": 644,
      "EndAddress": 653,
      "SectionType": 2
    },
    {
      "StartAddress": 654,
      "EndAddress": 1133,
      "SectionType": 1
    },
    {
      "StartAddress": 1134,
      "EndAddress": 1138,
      "SectionType": 2
    },
    {
      "StartAddress": 1139,
      "EndAddress": 1143,
      "SectionType": 2
    },
    {
      "StartAddress": 1144,
      "EndAddress": 1148,
      "SectionType": 2
    },
    {
      "StartAddress": 1149,
      "EndAddress": 1153,
      "SectionType": 2
    },
    {
      "StartAddress": 1154,
      "EndAddress": 1158,
      "SectionType": 2
    },
    {
      "StartAddress": 1159,
      "EndAddress": 1163,
      "SectionType": 2
    },
    {
      "StartAddress": 1164,
      "EndAddress": 1168,
      "SectionType": 2
    },
    {
      "StartAddress": 1169,
      "EndAddress": 1173,
      "SectionType": 2
    },
    {
      "StartAddress": 1174,
      "EndAddress": 1178,
      "SectionType": 2
    },
    {
      "StartAddress": 1179,
      "EndAddress": 1183,
      "SectionType": 2
    },
    {
      "StartAddress": 1184,
      "EndAddress": 1188,
      "SectionType": 2
    },
    {
      "StartAddress": 1189,
      "EndAddress": 1193,
      "SectionType": 2
    },
    {
      "StartAddress": 1194,
      "EndAddress": 1217,
      "SectionType": 2
    },
    {
      "StartAddress": 1218,
      "EndAddress": 2464,
      "SectionType": 1
    },
    {
      "StartAddress": 2465,
      "EndAddress": 2465,
      "SectionType": 2
    },
    {
      "StartAddress": 2466,
      "EndAddress": 2496,
      "SectionType": 2
    },
    {
      "StartAddress": 2497,
      "EndAddress": 2506,
      "SectionType": 2
    },
    {
      "StartAddress": 2507,
      "EndAddress": 2521,
      "SectionType": 2
    },
    {
      "StartAddress": 2522,
      "EndAddress": 2539,
      "SectionType": 2
    },
    {
      "StartAddress": 2540,
      "EndAddress": 2547,
      "SectionType": 2
    },
    {
      "StartAddress": 2548,
      "EndAddress": 2576,
      "SectionType": 1
    },
    {
      "StartAddress": 2577,
      "EndAddress": 2594,
      "SectionType": 2
    },
    {
      "StartAddress": 2595,
      "EndAddress": 12996,
      "SectionType": 1
    },
    {
      "StartAddress": 12997,
      "EndAddress": 12999,
      "SectionType": 2
    },
    {
      "StartAddress": 13000,
      "EndAddress": 13003,
      "SectionType": 2
    },
    {
      "StartAddress": 13004,
      "EndAddress": 13005,
      "SectionType": 2
    },
    {
      "StartAddress": 13006,
      "EndAddress": 13010,
      "SectionType": 2
    },
    {
      "StartAddress": 13011,
      "EndAddress": 13014,
      "SectionType": 2
    },
    {
      "StartAddress": 13015,
      "EndAddress": 13146,
      "SectionType": 3
    },
    {
      "StartAddress": 13147,
      "EndAddress": 15615,
      "SectionType": 1
    },
    {
      "StartAddress": 15616,
      "EndAddress": 16383,
      "SectionType": 0
    },
    {
      "StartAddress": 23296,
      "EndAddress": 23551,
      "SectionType": 0
    },
    {
      "StartAddress": 23552,
      "EndAddress": 65535,
      "SectionType": 2
    }
  ]
}