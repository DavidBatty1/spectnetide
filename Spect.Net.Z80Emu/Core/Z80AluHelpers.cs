// ReSharper disable InconsistentNaming

using System;

namespace Spect.Net.Z80Emu.Core
{
    /// <summary>
    /// This partion of the class provides helper tables and
    /// methods for Z80 ALU operations
    /// </summary>
    public partial class Z80
    {
        /// <summary>
        /// Provides a table that contains the value of the F register after a 8-bit INC operation
        /// </summary>
        private static byte[] s_IncOpFlags;

        /// <summary>
        /// Provides a table that contains the value of the F register after a 8-bit DEC operation
        /// </summary>
        private static byte[] s_DecOpFlags;

        /// <summary>
        /// Stores the accepted AF results of a DAA operation. The first 8 bits of
        /// the index is the value of A before the DAA operation; the ramining 3 bits
        /// are H, N, and C flags respectively.
        /// The upper 8 bits of the value represent A, the lower 8 bits are for F.
        /// </summary>
        private static ushort[] s_DaaResults;

        /// <summary>
        /// Provides a table that contains the value of the F register after a 8-bit ADD/ADC operation.
        /// </summary>
        private static byte[] s_AdcFlags;

        /// <summary>
        /// Provides a table that contains the value of the F register after a 8-bit SUB/SBC operation.
        /// </summary>
        private static byte[] s_SbcFlags;

        /// <summary>
        /// Provides a table that contains the value of the F register after an
        /// 8-bit ALU bitwise logic operation (according to the result).
        /// </summary>
        private static byte[] s_AluLogOpFlags;

        /// <summary>
        /// Provides a table tha defines the functions for ALU operation types
        /// </summary>
        private Action<byte,bool>[] _AluAlgorithms;

        /// <summary>
        /// Initializes the helper tables used for ALU operations
        /// </summary>
        private void InitializeAluTables()
        {
            _AluAlgorithms = new Action<byte, bool>[]
            {
                AluADD,
                AluADC,
                AluSUB,
                AluSBC,
                AluAND,
                AluXOR,
                AluOR,
                AluCP
            };

            // --- 8 bit INC operation flags
            s_IncOpFlags = new byte[0x100];
            for (var b = 0; b < 0x100; b++)
            {
                var oldVal = (byte) b;
                var newVal = (byte) (oldVal + 1);
                var flags =
                    // C is unaffected, we keep it false
                    (newVal & FlagsSetMask.R3) |
                    (newVal & FlagsSetMask.R5) |
                    ((newVal & 0x80) != 0 ? FlagsSetMask.S : 0) |
                    (newVal == 0 ? FlagsSetMask.Z : 0) |
                    ((oldVal & 0x0F) == 0x0F ? FlagsSetMask.H : 0) |
                    (oldVal == 0x7F ? FlagsSetMask.PV : 0);
                // N is false
                s_IncOpFlags[b] = (byte) flags;
            }

            // --- 8 bit DEC operation flags
            s_DecOpFlags = new byte[0x100];
            for (var b = 0; b < 0x100; b++)
            {
                var oldVal = (byte) b;
                var newVal = (byte) (oldVal - 1);
                var flags =
                    // C is unaffected, we keep it false
                    (newVal & FlagsSetMask.R3) |
                    (newVal & FlagsSetMask.R5) |
                    ((newVal & 0x80) != 0 ? FlagsSetMask.S : 0) |
                    (newVal == 0 ? FlagsSetMask.Z : 0) |
                    ((oldVal & 0x0F) == 0x00 ? FlagsSetMask.H : 0) |
                    (oldVal == 0x80 ? FlagsSetMask.PV : 0) |
                    FlagsSetMask.N;
                s_DecOpFlags[b] = (byte) flags;
            }

            // --- DAA flags table
            s_DaaResults = new ushort[0x800];
            for (var b = 0; b < 0x100; b++)
            {
                var hNibble = b >> 4;
                var lNibble = b & 0x0F;

                for (var H = 0; H <= 1; H++)
                {
                    for (var N = 0; N <= 1; N++)
                    {
                        for (var C = 0; C <= 1; C++)
                        {
                            // --- Calculate DIFF and the new value of C Flag
                            var diff = 0x00;
                            var cAfter = 0;
                            if (C == 0)
                            {
                                if (hNibble >= 0 && hNibble <= 9 && lNibble >= 0 && lNibble <= 9)
                                {
                                    diff = H == 0 ? 0x00 : 0x06;
                                }
                                else if (hNibble >= 0 && hNibble <= 8 && lNibble >= 0x0A && lNibble <= 0xF)
                                {
                                    diff = 0x06;
                                }
                                else if (hNibble >= 0x0A && hNibble <= 0x0F && lNibble >= 0 && lNibble <= 9 && H == 0)
                                {
                                    diff = 0x60;
                                }
                                else if (hNibble >= 9 && hNibble <= 0x0F && lNibble >= 0x0A && lNibble <= 0xF)
                                {
                                    diff = 0x66;
                                    cAfter = 1;
                                }
                                else if (hNibble >= 0x0A && hNibble <= 0x0F && lNibble >= 0 && lNibble <= 9)
                                {
                                    if (H == 1) diff = 0x66;
                                    cAfter = 1;
                                }
                            }
                            else
                            {
                                // C == 1
                                cAfter = 1;
                                if (lNibble >= 0 && lNibble <= 9)
                                {
                                    diff = H == 0 ? 0x60 : 0x66;
                                }
                                else if (lNibble >= 0x0A && lNibble <= 0x0F)
                                {
                                    diff = 0x66;
                                }
                            }

                            // --- Calculate new value of H Flag
                            var hAfter = 0;
                            if (lNibble >= 0x0A && lNibble <= 0x0F && N == 0
                                || lNibble >= 0 && lNibble <= 5 && N == 1 && H == 1)
                            {
                                hAfter = 1;
                            }

                            // --- Calculate new value of register A
                            var A = (N == 0 ? b + diff : b - diff) & 0xFF;

                            // --- Calculate other flags
                            var aPar = 0;
                            var val = A;
                            for (var i = 0; i < 8; i++)
                            {
                                aPar += val & 0x01;
                                val >>= 1;
                            }

                            // --- Calculate result
                            var fAfter =
                                (A & FlagsSetMask.R3) |
                                (A & FlagsSetMask.R5) |
                                ((A & 0x80) != 0 ? FlagsSetMask.S : 0) |
                                (A == 0 ? FlagsSetMask.Z : 0) |
                                (aPar % 2 == 0 ? FlagsSetMask.PV : 0) |
                                (N == 1 ? FlagsSetMask.N : 0) |
                                (hAfter == 1 ? FlagsSetMask.H : 0) |
                                (cAfter == 1 ? FlagsSetMask.C : 0);

                            var result = (ushort) (A << 8 | (byte) fAfter);
                            var fBefore = (byte) (H * 4 + N * 2 + C);
                            var idx = (fBefore << 8) + b;
                            s_DaaResults[idx] = result;
                        }
                    }
                }
            }

            // --- ADD and ADC flags
            s_AdcFlags = new byte[0x20000];
            for (var C = 0; C < 2; C++)
            {
                for (var X = 0; X < 0x100; X++)
                {
                    for (var Y = 0; Y < 0x100; Y++)
                    {
                        var res = (ushort) (X + Y + C);
                        var flags = 0;
                        if ((res & 0xFF) == 0) flags |= FlagsSetMask.Z;
                        flags |= res & (FlagsSetMask.R3 | FlagsSetMask.R5 | FlagsSetMask.S);
                        if (res >= 0x100) flags |= FlagsSetMask.C;
                        if ((((X & 0x0F) + (Y & 0x0F) + C) & 0x10) != 0) flags |= FlagsSetMask.H;
                        var ri = (sbyte) X + (sbyte) Y + C;
                        if (ri >= 0x80 || ri <= -0x81) flags |= FlagsSetMask.PV;
                        s_AdcFlags[C * 0x10000 + X * 0x100 + Y] = (byte) flags;
                    }
                }
            }

            // --- SUB and SBC flags
            s_SbcFlags = new byte[0x20000];
            for (var C = 0; C < 2; C++)
            {
                for (var X = 0; X < 0x100; X++)
                {
                    for (var Y = 0; Y < 0x100; Y++)
                    {
                        var res = X - Y - C;
                        var flags = res & (FlagsSetMask.R3 | FlagsSetMask.R5 | FlagsSetMask.S);
                        if ((res & 0xFF) == 0) flags |= FlagsSetMask.Z;
                        if ((res & 0x10000) != 0) flags |= FlagsSetMask.C;
                        var ri = (sbyte) X - (sbyte) Y - C;
                        if (ri >= 0x80 || ri < -0x80) flags |= FlagsSetMask.PV;
                        if ((((X & 0x0F) - (res & 0x0F) - C) & 0x10) != 0) flags |= FlagsSetMask.H;
                        flags |= FlagsSetMask.N;
                        s_SbcFlags[C * 0x10000 + X * 0x100 + Y] = (byte) flags;
                    }
                }
            }

            // --- ALU log operation (AND, XOR, OR) flags
            s_AluLogOpFlags = new byte[0x100];
            for (var b = 0; b < 0x100; b++)
            {
                var fl = b & (FlagsSetMask.R3 | FlagsSetMask.R5 | FlagsSetMask.S);
                var p = FlagsSetMask.PV;
                for (var i = 0x80; i != 0; i /= 2)
                {
                    if ((b & i) != 0) p ^= FlagsSetMask.PV;
                }
                s_AluLogOpFlags[b] = (byte)(fl | p);
            }
            s_AluLogOpFlags[0] |= FlagsSetMask.Z;
        }

        /// <summary>
        /// Provides a table that contains the value of the F register after an
        /// 8-bit ALU RLC operation (according to the result).
        /// </summary>
        private static readonly byte[] s_RlcFlags =
        {
            0x44, 0x00, 0x00, 0x04, 0x08, 0x0C, 0x0C, 0x08, 0x00, 0x04, 0x04, 0x00, 0x0C, 0x08, 0x08, 0x0C,
            0x20, 0x24, 0x24, 0x20, 0x2C, 0x28, 0x28, 0x2C, 0x24, 0x20, 0x20, 0x24, 0x28, 0x2C, 0x2C, 0x28,
            0x00, 0x04, 0x04, 0x00, 0x0C, 0x08, 0x08, 0x0C, 0x04, 0x00, 0x00, 0x04, 0x08, 0x0C, 0x0C, 0x08,
            0x24, 0x20, 0x20, 0x24, 0x28, 0x2C, 0x2C, 0x28, 0x20, 0x24, 0x24, 0x20, 0x2C, 0x28, 0x28, 0x2C,
            0x80, 0x84, 0x84, 0x80, 0x8C, 0x88, 0x88, 0x8C, 0x84, 0x80, 0x80, 0x84, 0x88, 0x8C, 0x8C, 0x88,
            0xA4, 0xA0, 0xA0, 0xA4, 0xA8, 0xAC, 0xAC, 0xA8, 0xA0, 0xA4, 0xA4, 0xA0, 0xAC, 0xA8, 0xA8, 0xAC,
            0x84, 0x80, 0x80, 0x84, 0x88, 0x8C, 0x8C, 0x88, 0x80, 0x84, 0x84, 0x80, 0x8C, 0x88, 0x88, 0x8C,
            0xA0, 0xA4, 0xA4, 0xA0, 0xAC, 0xA8, 0xA8, 0xAC, 0xA4, 0xA0, 0xA0, 0xA4, 0xA8, 0xAC, 0xAC, 0xA8,
            0x01, 0x05, 0x05, 0x01, 0x0D, 0x09, 0x09, 0x0D, 0x05, 0x01, 0x01, 0x05, 0x09, 0x0D, 0x0D, 0x09,
            0x25, 0x21, 0x21, 0x25, 0x29, 0x2D, 0x2D, 0x29, 0x21, 0x25, 0x25, 0x21, 0x2D, 0x29, 0x29, 0x2D,
            0x05, 0x01, 0x01, 0x05, 0x09, 0x0D, 0x0D, 0x09, 0x01, 0x05, 0x05, 0x01, 0x0D, 0x09, 0x09, 0x0D,
            0x21, 0x25, 0x25, 0x21, 0x2D, 0x29, 0x29, 0x2D, 0x25, 0x21, 0x21, 0x25, 0x29, 0x2D, 0x2D, 0x29,
            0x85, 0x81, 0x81, 0x85, 0x89, 0x8D, 0x8D, 0x89, 0x81, 0x85, 0x85, 0x81, 0x8D, 0x89, 0x89, 0x8D,
            0xA1, 0xA5, 0xA5, 0xA1, 0xAD, 0xA9, 0xA9, 0xAD, 0xA5, 0xA1, 0xA1, 0xA5, 0xA9, 0xAD, 0xAD, 0xA9,
            0x81, 0x85, 0x85, 0x81, 0x8D, 0x89, 0x89, 0x8D, 0x85, 0x81, 0x81, 0x85, 0x89, 0x8D, 0x8D, 0x89,
            0xA5, 0xA1, 0xA1, 0xA5, 0xA9, 0xAD, 0xAD, 0xA9, 0xA1, 0xA5, 0xA5, 0xA1, 0xAD, 0xA9, 0xA9, 0xAD
        };

        /// <summary>
        /// Provides a table that contains the value of the F register after an
        /// 8-bit ALU RRC operation (according to the result).
        /// </summary>
        private static readonly byte[] s_RrcFlags =
        {
            0x44, 0x81, 0x00, 0x85, 0x00, 0x85, 0x04, 0x81, 0x00, 0x85, 0x04, 0x81, 0x04, 0x81, 0x00, 0x85,
            0x08, 0x8D, 0x0C, 0x89, 0x0C, 0x89, 0x08, 0x8D, 0x0C, 0x89, 0x08, 0x8D, 0x08, 0x8D, 0x0C, 0x89,
            0x00, 0x85, 0x04, 0x81, 0x04, 0x81, 0x00, 0x85, 0x04, 0x81, 0x00, 0x85, 0x00, 0x85, 0x04, 0x81,
            0x0C, 0x89, 0x08, 0x8D, 0x08, 0x8D, 0x0C, 0x89, 0x08, 0x8D, 0x0C, 0x89, 0x0C, 0x89, 0x08, 0x8D,
            0x20, 0xA5, 0x24, 0xA1, 0x24, 0xA1, 0x20, 0xA5, 0x24, 0xA1, 0x20, 0xA5, 0x20, 0xA5, 0x24, 0xA1,
            0x2C, 0xA9, 0x28, 0xAD, 0x28, 0xAD, 0x2C, 0xA9, 0x28, 0xAD, 0x2C, 0xA9, 0x2C, 0xA9, 0x28, 0xAD,
            0x24, 0xA1, 0x20, 0xA5, 0x20, 0xA5, 0x24, 0xA1, 0x20, 0xA5, 0x24, 0xA1, 0x24, 0xA1, 0x20, 0xA5,
            0x28, 0xAD, 0x2C, 0xA9, 0x2C, 0xA9, 0x28, 0xAD, 0x2C, 0xA9, 0x28, 0xAD, 0x28, 0xAD, 0x2C, 0xA9,
            0x00, 0x85, 0x04, 0x81, 0x04, 0x81, 0x00, 0x85, 0x04, 0x81, 0x00, 0x85, 0x00, 0x85, 0x04, 0x81,
            0x0C, 0x89, 0x08, 0x8D, 0x08, 0x8D, 0x0C, 0x89, 0x08, 0x8D, 0x0C, 0x89, 0x0C, 0x89, 0x08, 0x8D,
            0x04, 0x81, 0x00, 0x85, 0x00, 0x85, 0x04, 0x81, 0x00, 0x85, 0x04, 0x81, 0x04, 0x81, 0x00, 0x85,
            0x08, 0x8D, 0x0C, 0x89, 0x0C, 0x89, 0x08, 0x8D, 0x0C, 0x89, 0x08, 0x8D, 0x08, 0x8D, 0x0C, 0x89,
            0x24, 0xA1, 0x20, 0xA5, 0x20, 0xA5, 0x24, 0xA1, 0x20, 0xA5, 0x24, 0xA1, 0x24, 0xA1, 0x20, 0xA5,
            0x28, 0xAD, 0x2C, 0xA9, 0x2C, 0xA9, 0x28, 0xAD, 0x2C, 0xA9, 0x28, 0xAD, 0x28, 0xAD, 0x2C, 0xA9,
            0x20, 0xA5, 0x24, 0xA1, 0x24, 0xA1, 0x20, 0xA5, 0x24, 0xA1, 0x20, 0xA5, 0x20, 0xA5, 0x24, 0xA1,
            0x2C, 0xA9, 0x28, 0xAD, 0x28, 0xAD, 0x2C, 0xA9, 0x28, 0xAD, 0x2C, 0xA9, 0x2C, 0xA9, 0x28, 0xAD
        };

        /// <summary>
        /// Provides a table that contains the value of the F register after an
        /// 8-bit ALU RL operation with a previous Carry flag value of 1 (according to the result).
        /// This table supports the ALU SLA operation, too.
        /// </summary>
        private static readonly byte[] s_RlCarry0Flags =
        {
            0x44, 0x00, 0x00, 0x04, 0x08, 0x0C, 0x0C, 0x08, 0x00, 0x04, 0x04, 0x00, 0x0C, 0x08, 0x08, 0x0C,
            0x20, 0x24, 0x24, 0x20, 0x2C, 0x28, 0x28, 0x2C, 0x24, 0x20, 0x20, 0x24, 0x28, 0x2C, 0x2C, 0x28,
            0x00, 0x04, 0x04, 0x00, 0x0C, 0x08, 0x08, 0x0C, 0x04, 0x00, 0x00, 0x04, 0x08, 0x0C, 0x0C, 0x08,
            0x24, 0x20, 0x20, 0x24, 0x28, 0x2C, 0x2C, 0x28, 0x20, 0x24, 0x24, 0x20, 0x2C, 0x28, 0x28, 0x2C,
            0x80, 0x84, 0x84, 0x80, 0x8C, 0x88, 0x88, 0x8C, 0x84, 0x80, 0x80, 0x84, 0x88, 0x8C, 0x8C, 0x88,
            0xA4, 0xA0, 0xA0, 0xA4, 0xA8, 0xAC, 0xAC, 0xA8, 0xA0, 0xA4, 0xA4, 0xA0, 0xAC, 0xA8, 0xA8, 0xAC,
            0x84, 0x80, 0x80, 0x84, 0x88, 0x8C, 0x8C, 0x88, 0x80, 0x84, 0x84, 0x80, 0x8C, 0x88, 0x88, 0x8C,
            0xA0, 0xA4, 0xA4, 0xA0, 0xAC, 0xA8, 0xA8, 0xAC, 0xA4, 0xA0, 0xA0, 0xA4, 0xA8, 0xAC, 0xAC, 0xA8,
            0x45, 0x01, 0x01, 0x05, 0x09, 0x0D, 0x0D, 0x09, 0x01, 0x05, 0x05, 0x01, 0x0D, 0x09, 0x09, 0x0D,
            0x21, 0x25, 0x25, 0x21, 0x2D, 0x29, 0x29, 0x2D, 0x25, 0x21, 0x21, 0x25, 0x29, 0x2D, 0x2D, 0x29,
            0x01, 0x05, 0x05, 0x01, 0x0D, 0x09, 0x09, 0x0D, 0x05, 0x01, 0x01, 0x05, 0x09, 0x0D, 0x0D, 0x09,
            0x25, 0x21, 0x21, 0x25, 0x29, 0x2D, 0x2D, 0x29, 0x21, 0x25, 0x25, 0x21, 0x2D, 0x29, 0x29, 0x2D,
            0x81, 0x85, 0x85, 0x81, 0x8D, 0x89, 0x89, 0x8D, 0x85, 0x81, 0x81, 0x85, 0x89, 0x8D, 0x8D, 0x89,
            0xA5, 0xA1, 0xA1, 0xA5, 0xA9, 0xAD, 0xAD, 0xA9, 0xA1, 0xA5, 0xA5, 0xA1, 0xAD, 0xA9, 0xA9, 0xAD,
            0x85, 0x81, 0x81, 0x85, 0x89, 0x8D, 0x8D, 0x89, 0x81, 0x85, 0x85, 0x81, 0x8D, 0x89, 0x89, 0x8D,
            0xA1, 0xA5, 0xA5, 0xA1, 0xAD, 0xA9, 0xA9, 0xAD, 0xA5, 0xA1, 0xA1, 0xA5, 0xA9, 0xAD, 0xAD, 0xA9
        };

        /// <summary>
        /// Provides a table that contains the value of the F register after an
        /// 8-bit ALU RL operation with a previous Carry flag value of 1 (according to the result).
        /// </summary>
        private static readonly byte[] s_RlCarry1Flags =
        {
            0x00, 0x04, 0x04, 0x00, 0x0C, 0x08, 0x08, 0x0C, 0x04, 0x00, 0x00, 0x04, 0x08, 0x0C, 0x0C, 0x08,
            0x24, 0x20, 0x20, 0x24, 0x28, 0x2C, 0x2C, 0x28, 0x20, 0x24, 0x24, 0x20, 0x2C, 0x28, 0x28, 0x2C,
            0x04, 0x00, 0x00, 0x04, 0x08, 0x0C, 0x0C, 0x08, 0x00, 0x04, 0x04, 0x00, 0x0C, 0x08, 0x08, 0x0C,
            0x20, 0x24, 0x24, 0x20, 0x2C, 0x28, 0x28, 0x2C, 0x24, 0x20, 0x20, 0x24, 0x28, 0x2C, 0x2C, 0x28,
            0x84, 0x80, 0x80, 0x84, 0x88, 0x8C, 0x8C, 0x88, 0x80, 0x84, 0x84, 0x80, 0x8C, 0x88, 0x88, 0x8C,
            0xA0, 0xA4, 0xA4, 0xA0, 0xAC, 0xA8, 0xA8, 0xAC, 0xA4, 0xA0, 0xA0, 0xA4, 0xA8, 0xAC, 0xAC, 0xA8,
            0x80, 0x84, 0x84, 0x80, 0x8C, 0x88, 0x88, 0x8C, 0x84, 0x80, 0x80, 0x84, 0x88, 0x8C, 0x8C, 0x88,
            0xA4, 0xA0, 0xA0, 0xA4, 0xA8, 0xAC, 0xAC, 0xA8, 0xA0, 0xA4, 0xA4, 0xA0, 0xAC, 0xA8, 0xA8, 0xAC,
            0x01, 0x05, 0x05, 0x01, 0x0D, 0x09, 0x09, 0x0D, 0x05, 0x01, 0x01, 0x05, 0x09, 0x0D, 0x0D, 0x09,
            0x25, 0x21, 0x21, 0x25, 0x29, 0x2D, 0x2D, 0x29, 0x21, 0x25, 0x25, 0x21, 0x2D, 0x29, 0x29, 0x2D,
            0x05, 0x01, 0x01, 0x05, 0x09, 0x0D, 0x0D, 0x09, 0x01, 0x05, 0x05, 0x01, 0x0D, 0x09, 0x09, 0x0D,
            0x21, 0x25, 0x25, 0x21, 0x2D, 0x29, 0x29, 0x2D, 0x25, 0x21, 0x21, 0x25, 0x29, 0x2D, 0x2D, 0x29,
            0x85, 0x81, 0x81, 0x85, 0x89, 0x8D, 0x8D, 0x89, 0x81, 0x85, 0x85, 0x81, 0x8D, 0x89, 0x89, 0x8D,
            0xA1, 0xA5, 0xA5, 0xA1, 0xAD, 0xA9, 0xA9, 0xAD, 0xA5, 0xA1, 0xA1, 0xA5, 0xA9, 0xAD, 0xAD, 0xA9,
            0x81, 0x85, 0x85, 0x81, 0x8D, 0x89, 0x89, 0x8D, 0x85, 0x81, 0x81, 0x85, 0x89, 0x8D, 0x8D, 0x89,
            0xA5, 0xA1, 0xA1, 0xA5, 0xA9, 0xAD, 0xAD, 0xA9, 0xA1, 0xA5, 0xA5, 0xA1, 0xAD, 0xA9, 0xA9, 0xAD
        };

        /// <summary>
        /// Provides a table that contains the value of the F register after an
        /// 8-bit ALU RL operation with a previous Carry flag value of 1 (according to the result).
        /// This table supports the ALU SRA operation, too.
        /// </summary>
        private static readonly byte[] s_RrCarry0Flags =
        {
            0x44, 0x45, 0x00, 0x01, 0x00, 0x01, 0x04, 0x05, 0x00, 0x01, 0x04, 0x05, 0x04, 0x05, 0x00, 0x01,
            0x08, 0x09, 0x0C, 0x0D, 0x0C, 0x0D, 0x08, 0x09, 0x0C, 0x0D, 0x08, 0x09, 0x08, 0x09, 0x0C, 0x0D,
            0x00, 0x01, 0x04, 0x05, 0x04, 0x05, 0x00, 0x01, 0x04, 0x05, 0x00, 0x01, 0x00, 0x01, 0x04, 0x05,
            0x0C, 0x0D, 0x08, 0x09, 0x08, 0x09, 0x0C, 0x0D, 0x08, 0x09, 0x0C, 0x0D, 0x0C, 0x0D, 0x08, 0x09,
            0x20, 0x21, 0x24, 0x25, 0x24, 0x25, 0x20, 0x21, 0x24, 0x25, 0x20, 0x21, 0x20, 0x21, 0x24, 0x25,
            0x2C, 0x2D, 0x28, 0x29, 0x28, 0x29, 0x2C, 0x2D, 0x28, 0x29, 0x2C, 0x2D, 0x2C, 0x2D, 0x28, 0x29,
            0x24, 0x25, 0x20, 0x21, 0x20, 0x21, 0x24, 0x25, 0x20, 0x21, 0x24, 0x25, 0x24, 0x25, 0x20, 0x21,
            0x28, 0x29, 0x2C, 0x2D, 0x2C, 0x2D, 0x28, 0x29, 0x2C, 0x2D, 0x28, 0x29, 0x28, 0x29, 0x2C, 0x2D,
            0x00, 0x01, 0x04, 0x05, 0x04, 0x05, 0x00, 0x01, 0x04, 0x05, 0x00, 0x01, 0x00, 0x01, 0x04, 0x05,
            0x0C, 0x0D, 0x08, 0x09, 0x08, 0x09, 0x0C, 0x0D, 0x08, 0x09, 0x0C, 0x0D, 0x0C, 0x0D, 0x08, 0x09,
            0x04, 0x05, 0x00, 0x01, 0x00, 0x01, 0x04, 0x05, 0x00, 0x01, 0x04, 0x05, 0x04, 0x05, 0x00, 0x01,
            0x08, 0x09, 0x0C, 0x0D, 0x0C, 0x0D, 0x08, 0x09, 0x0C, 0x0D, 0x08, 0x09, 0x08, 0x09, 0x0C, 0x0D,
            0x24, 0x25, 0x20, 0x21, 0x20, 0x21, 0x24, 0x25, 0x20, 0x21, 0x24, 0x25, 0x24, 0x25, 0x20, 0x21,
            0x28, 0x29, 0x2C, 0x2D, 0x2C, 0x2D, 0x28, 0x29, 0x2C, 0x2D, 0x28, 0x29, 0x28, 0x29, 0x2C, 0x2D,
            0x20, 0x21, 0x24, 0x25, 0x24, 0x25, 0x20, 0x21, 0x24, 0x25, 0x20, 0x21, 0x20, 0x21, 0x24, 0x25,
            0x2C, 0x2D, 0x28, 0x29, 0x28, 0x29, 0x2C, 0x2D, 0x28, 0x29, 0x2C, 0x2D, 0x2C, 0x2D, 0x28, 0x29
        };

        /// <summary>
        /// Provides a table that contains the value of the F register after an
        /// 8-bit ALU RL operation with a previous Carry flag value of 1 (according to the result).
        /// </summary>
        private static readonly byte[] s_RrCarry1Flags =
        {
            0x80, 0x81, 0x84, 0x85, 0x84, 0x85, 0x80, 0x81, 0x84, 0x85, 0x80, 0x81, 0x80, 0x81, 0x84, 0x85,
            0x8C, 0x8D, 0x88, 0x89, 0x88, 0x89, 0x8C, 0x8D, 0x88, 0x89, 0x8C, 0x8D, 0x8C, 0x8D, 0x88, 0x89,
            0x84, 0x85, 0x80, 0x81, 0x80, 0x81, 0x84, 0x85, 0x80, 0x81, 0x84, 0x85, 0x84, 0x85, 0x80, 0x81,
            0x88, 0x89, 0x8C, 0x8D, 0x8C, 0x8D, 0x88, 0x89, 0x8C, 0x8D, 0x88, 0x89, 0x88, 0x89, 0x8C, 0x8D,
            0xA4, 0xA5, 0xA0, 0xA1, 0xA0, 0xA1, 0xA4, 0xA5, 0xA0, 0xA1, 0xA4, 0xA5, 0xA4, 0xA5, 0xA0, 0xA1,
            0xA8, 0xA9, 0xAC, 0xAD, 0xAC, 0xAD, 0xA8, 0xA9, 0xAC, 0xAD, 0xA8, 0xA9, 0xA8, 0xA9, 0xAC, 0xAD,
            0xA0, 0xA1, 0xA4, 0xA5, 0xA4, 0xA5, 0xA0, 0xA1, 0xA4, 0xA5, 0xA0, 0xA1, 0xA0, 0xA1, 0xA4, 0xA5,
            0xAC, 0xAD, 0xA8, 0xA9, 0xA8, 0xA9, 0xAC, 0xAD, 0xA8, 0xA9, 0xAC, 0xAD, 0xAC, 0xAD, 0xA8, 0xA9,
            0x84, 0x85, 0x80, 0x81, 0x80, 0x81, 0x84, 0x85, 0x80, 0x81, 0x84, 0x85, 0x84, 0x85, 0x80, 0x81,
            0x88, 0x89, 0x8C, 0x8D, 0x8C, 0x8D, 0x88, 0x89, 0x8C, 0x8D, 0x88, 0x89, 0x88, 0x89, 0x8C, 0x8D,
            0x80, 0x81, 0x84, 0x85, 0x84, 0x85, 0x80, 0x81, 0x84, 0x85, 0x80, 0x81, 0x80, 0x81, 0x84, 0x85,
            0x8C, 0x8D, 0x88, 0x89, 0x88, 0x89, 0x8C, 0x8D, 0x88, 0x89, 0x8C, 0x8D, 0x8C, 0x8D, 0x88, 0x89,
            0xA0, 0xA1, 0xA4, 0xA5, 0xA4, 0xA5, 0xA0, 0xA1, 0xA4, 0xA5, 0xA0, 0xA1, 0xA0, 0xA1, 0xA4, 0xA5,
            0xAC, 0xAD, 0xA8, 0xA9, 0xA8, 0xA9, 0xAC, 0xAD, 0xA8, 0xA9, 0xAC, 0xAD, 0xAC, 0xAD, 0xA8, 0xA9,
            0xA4, 0xA5, 0xA0, 0xA1, 0xA0, 0xA1, 0xA4, 0xA5, 0xA0, 0xA1, 0xA4, 0xA5, 0xA4, 0xA5, 0xA0, 0xA1,
            0xA8, 0xA9, 0xAC, 0xAD, 0xAC, 0xAD, 0xA8, 0xA9, 0xAC, 0xAD, 0xA8, 0xA9, 0xA8, 0xA9, 0xAC, 0xAD
        };

        /// <summary>
        /// Provides a table that contains the value of the F register after an
        /// 8-bit ALU SRA operation (according to the result).
        /// </summary>
        private static readonly byte[] s_SraFlags =
        {
            0x44, 0x45, 0x00, 0x01, 0x00, 0x01, 0x04, 0x05, 0x00, 0x01, 0x04, 0x05, 0x04, 0x05, 0x00, 0x01,
            0x08, 0x09, 0x0C, 0x0D, 0x0C, 0x0D, 0x08, 0x09, 0x0C, 0x0D, 0x08, 0x09, 0x08, 0x09, 0x0C, 0x0D,
            0x00, 0x01, 0x04, 0x05, 0x04, 0x05, 0x00, 0x01, 0x04, 0x05, 0x00, 0x01, 0x00, 0x01, 0x04, 0x05,
            0x0C, 0x0D, 0x08, 0x09, 0x08, 0x09, 0x0C, 0x0D, 0x08, 0x09, 0x0C, 0x0D, 0x0C, 0x0D, 0x08, 0x09,
            0x20, 0x21, 0x24, 0x25, 0x24, 0x25, 0x20, 0x21, 0x24, 0x25, 0x20, 0x21, 0x20, 0x21, 0x24, 0x25,
            0x2C, 0x2D, 0x28, 0x29, 0x28, 0x29, 0x2C, 0x2D, 0x28, 0x29, 0x2C, 0x2D, 0x2C, 0x2D, 0x28, 0x29,
            0x24, 0x25, 0x20, 0x21, 0x20, 0x21, 0x24, 0x25, 0x20, 0x21, 0x24, 0x25, 0x24, 0x25, 0x20, 0x21,
            0x28, 0x29, 0x2C, 0x2D, 0x2C, 0x2D, 0x28, 0x29, 0x2C, 0x2D, 0x28, 0x29, 0x28, 0x29, 0x2C, 0x2D,
            0x84, 0x85, 0x80, 0x81, 0x80, 0x81, 0x84, 0x85, 0x80, 0x81, 0x84, 0x85, 0x84, 0x85, 0x80, 0x81,
            0x88, 0x89, 0x8C, 0x8D, 0x8C, 0x8D, 0x88, 0x89, 0x8C, 0x8D, 0x88, 0x89, 0x88, 0x89, 0x8C, 0x8D,
            0x80, 0x81, 0x84, 0x85, 0x84, 0x85, 0x80, 0x81, 0x84, 0x85, 0x80, 0x81, 0x80, 0x81, 0x84, 0x85,
            0x8C, 0x8D, 0x88, 0x89, 0x88, 0x89, 0x8C, 0x8D, 0x88, 0x89, 0x8C, 0x8D, 0x8C, 0x8D, 0x88, 0x89,
            0xA0, 0xA1, 0xA4, 0xA5, 0xA4, 0xA5, 0xA0, 0xA1, 0xA4, 0xA5, 0xA0, 0xA1, 0xA0, 0xA1, 0xA4, 0xA5,
            0xAC, 0xAD, 0xA8, 0xA9, 0xA8, 0xA9, 0xAC, 0xAD, 0xA8, 0xA9, 0xAC, 0xAD, 0xAC, 0xAD, 0xA8, 0xA9,
            0xA4, 0xA5, 0xA0, 0xA1, 0xA0, 0xA1, 0xA4, 0xA5, 0xA0, 0xA1, 0xA4, 0xA5, 0xA4, 0xA5, 0xA0, 0xA1,
            0xA8, 0xA9, 0xAC, 0xAD, 0xAC, 0xAD, 0xA8, 0xA9, 0xAC, 0xAD, 0xA8, 0xA9, 0xA8, 0xA9, 0xAC, 0xAD
        };

        /// <summary>
        /// Increments the specified value and sets F according to INC ALU logic
        /// </summary>
        /// <param name="val">Value to increment</param>
        /// <returns>Incremented value</returns>
        private byte AluIncByte(byte val)
        {
            Registers.F = (byte)(s_IncOpFlags[val] | Registers.F & FlagsSetMask.C);
            val++;
            return val;
        }

        /// <summary>
        /// Increments the specified value and sets F according to INC ALU logic
        /// </summary>
        /// <param name="val">Value to increment</param>
        /// <returns>Incremented value</returns>
        private byte AluDecByte(byte val)
        {
            Registers.F = (byte)(s_DecOpFlags[val] | Registers.F & FlagsSetMask.C);
            val--;
            return val;
        }

        /// <summary>
        /// Adds the <paramref name="regHL"/> value and <paramref name="regOther"/> value
        /// according to the rule of ADD HL,QQ operation
        /// </summary>
        /// <param name="regHL">HL (IX, IY) value</param>
        /// <param name="regOther">Other value</param>
        /// <returns>Result value</returns>
        private ushort AluAddHL(ushort regHL, ushort regOther)
        {
            // --- Keep unaffected flags
            Registers.F = (byte)(Registers.F & ~(FlagsSetMask.N | FlagsSetMask.C 
                                                 | FlagsSetMask.R5 | FlagsSetMask.R3 | FlagsSetMask.H));

            // --- Calculate Carry from bit 11
            Registers.F |= (byte)((((regHL & 0x0FFF) + (regOther & 0x0FFF)) >> 8) & FlagsSetMask.H);
            var res = (uint)((regHL & 0xFFFF) + (regOther & 0xFFFF));

            // --- Calculate Carry
            if ((res & 0x10000) != 0) Registers.F |= FlagsSetMask.C;

            // --- Set R5 and R3 according to the low 8-bit of result
            Registers.F |= (byte)((byte)((res >> 8) & 0xFF) & (FlagsSetMask.R5 | FlagsSetMask.R3));
            return (ushort)(res & 0xFFFF);
        }

        /// <summary>
        /// Executes the ADD operation.
        /// </summary>
        /// <param name="right">Right operand</param>
        /// <param name="cf">Carry flag</param>
        private void AluADD(byte right, bool cf)
        {
            AluADC(right, false);
        }

        /// <summary>
        /// Executes the ADC operation.
        /// </summary>
        /// <param name="right">Right operand</param>
        /// <param name="cf">Carry flag</param>
        private void AluADC(byte right, bool cf)
        {
            var c = cf ? 1 : 0;
            var result = Registers.A + right + c;
            var signed = (sbyte)Registers.A + (sbyte)right + c;
            var lNibble = ((Registers.A & 0x0F) + (right & 0x0F) + c) & 0x10;

            var flags = (byte)(result & (FlagsSetMask.S | FlagsSetMask.R5 | FlagsSetMask.R3));
            if ((result & 0xFF) == 0) flags |= FlagsSetMask.Z;
            if (result >= 0x100) flags |= FlagsSetMask.C;
            if (lNibble != 0) flags |= FlagsSetMask.H;
            if (signed >= 0x80 || signed <= -0x81) flags |= FlagsSetMask.PV;

            Registers.F = flags;
            Registers.A = (byte) result;
        }

        /// <summary>
        /// Executes the SUB operation.
        /// </summary>
        /// <param name="right">Right operand</param>
        /// <param name="cf">Carry flag</param>
        private void AluSUB(byte right, bool cf)
        {
            AluSBC(right, false);
        }

        /// <summary>
        /// Executes the SBC operation.
        /// </summary>
        /// <param name="right">Right operand</param>
        /// <param name="cf">Carry flag</param>
        private void AluSBC(byte right, bool cf)
        {
            var c = cf ? 1 : 0;
            var result = Registers.A - right - c;
            var signed = (sbyte)Registers.A - (sbyte)right - c;
            var lNibble = ((Registers.A & 0x0F) - (right & 0x0F) - c) & 0x10;

            var flags = (byte)(result & (FlagsSetMask.S | FlagsSetMask.R5 | FlagsSetMask.R3));
            flags |= FlagsSetMask.N;
            if ((result & 0xFF) == 0) flags |= FlagsSetMask.Z;
            if ((result & 0x10000) != 0) flags |= FlagsSetMask.C;
            if (lNibble != 0) flags |= FlagsSetMask.H;
            if (signed >= 0x80 || signed <= -0x81) flags |= FlagsSetMask.PV;

            Registers.F = flags;
            Registers.A = (byte)result;
        }

        /// <summary>
        /// Executes the AND operation.
        /// </summary>
        /// <param name="right">Right operand</param>
        /// <param name="cf">Carry flag</param>
        private void AluAND(byte right, bool cf)
        {
            Registers.A &= right;
            Registers.F = (byte)(s_AluLogOpFlags[Registers.A] | FlagsSetMask.H);
        }

        /// <summary>
        /// Executes the XOR operation.
        /// </summary>
        /// <param name="right">Right operand</param>
        /// <param name="cf">Carry flag</param>
        private void AluXOR(byte right, bool cf)
        {
            Registers.A ^= right;
            Registers.F = s_AluLogOpFlags[Registers.A];
        }

        /// <summary>
        /// Executes the OR operation.
        /// </summary>
        /// <param name="right">Right operand</param>
        /// <param name="cf">Carry flag</param>
        private void AluOR(byte right, bool cf)
        {
            Registers.A |= right;
            Registers.F = s_AluLogOpFlags[Registers.A];
        }

        /// <summary>
        /// Executes the CP operation.
        /// </summary>
        /// <param name="right">Right operand</param>
        /// <param name="cf">Carry flag</param>
        private void AluCP(byte right, bool cf)
        {
            // TODO: Review this method, potential issues!
            var result = Registers.A - right;
            var signed = (sbyte)Registers.A - (sbyte)right;
            var lNibble = ((Registers.A & 0x0F) - (right & 0x0F)) & 0x10;

            var flags = (byte)(result & (FlagsSetMask.S | FlagsSetMask.R5 | FlagsSetMask.R3));
            flags |= FlagsSetMask.N;
            if ((result & 0xFF) == 0) flags |= FlagsSetMask.Z;
            if ((result & 0x10000) != 0) flags |= FlagsSetMask.C;
            if (lNibble != 0) flags |= FlagsSetMask.H;
            if (signed >= 0x80 || signed <= -0x81) flags |= FlagsSetMask.PV;

            Registers.F = flags;
        }
    }
}